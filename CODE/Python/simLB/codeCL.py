"""
codeCL.py

script for writing OpenCL for the initialisation of all dist. functions
"""

import string
from math import sqrt

def genOpenCL(input,ex,ey,dx,dy):
    """
    write all OpenCL code
    return name of file containing OpenCL code
    """
    
    fileName = 'kernel.cl'
    
    f = open(fileName,'wt')
    f.write('// {}\n\n'.format(fileName))
    #f.write('#pragma OPENCL EXTENSION cl_amd_printf : enable \n')
    f.write('#pragma OPENCL EXTENSION cl_amd_fp64 : enable \n\n')
    #f.write('#pragma OPENCL EXTENSION cl_khr_fp64 : enable \n\n')
            
    #f.write('#pragma OPENCL EXTENSION cl_intel_printf : enable \n')
    #f.write('#pragma OPENCL EXTENSION cl_intel_fp64 : enable \n\n')
        
    f.write('/////////////////////////////////////////\n')
    f.write('//MACROS \n')
    f.write('/////////////////////////////////////////\n\n')
    f.write('#define F_G(x,y,i) f_G[x*Ni*Ny + y*Ni + i] \n')
    f.write('#define H_G(x,y,i) h_G[x*Ni*Ny + y*Ni + i] \n')
    f.write('#define BND(x,y) bnd[x*Ny + y] \n')
    f.write('#define CELL(i) cell[i] \n')
    f.write('#define DENSITY(i) density[i] \n')
    f.write('#define VELX(i) velX[i] \n')
    f.write('#define VELY(i) velY[i] \n')
    f.write('#define THERM(i) therm[i] \n')
    f.write('#define RHO_G(x,y) rho_G[x*Ny + y] \n')
    f.write('#define UX_G(x,y) ux_G[x*Ny + y] \n')
    f.write('#define UY_G(x,y) uy_G[x*Ny + y] \n')
    f.write('#define T_G(x,y)  T_G[x*Ny + y] \n\n')
    
    f.write('// macros for general use\n')
    f.write('#define F(x,y,i) f[x*Ni*Ny + y*Ni + i] \n')
    f.write('#define H(x,y,i) h[x*Ni*Ny + y*Ni + i] \n')
    f.write('#define F_FLUX_X(x,y,i) f_flux_x[x*Ni*Ny + y*Ni + i]\n')
    f.write('#define F_FLUX_Y(x,y,i) f_flux_y[x*Ni*Ny + y*Ni + i]\n')
    f.write('#define H_FLUX_X(x,y,i) h_flux_x[x*Ni*Ny + y*Ni + i]\n')
    f.write('#define H_FLUX_Y(x,y,i) h_flux_y[x*Ni*Ny + y*Ni + i]\n')
    
    f.write('\n')
    f.write('/////////////////////////////////////////\n')
    f.write('//CONSTANTS \n')
    f.write('/////////////////////////////////////////\n\n')
    f.write('#define Nx {}\n'.format(input['Nx']))
    f.write('#define Ny {}\n'.format(input['Ny']))
    f.write('#define Ni {} \n\n'.format(input['Ni']))
    f.write('__constant double mu = {};\n'.format(input['mu']))
    f.write('__constant double S_v = {};\n'.format(input['S_v']))
    f.write('__constant double T_ref = {};\n'.format(input['T_ref']))
    f.write('__constant double Pr = {};\n'.format(input['Pr']))
    f.write('__constant double R = {};\n'.format(input['R']))
    f.write('__constant double K = {};\n'.format(input['K']))
    f.write('__constant double b = {};\n'.format(input['b']))
    f.write('__constant double Tc = {};\n\n'.format(input['Tc']))
    f.write('__constant double dt = {};\n\n'.format(input['dt']))
    f.write('__constant int periodicX = {};\n'.format(input['periodicX']))
    f.write('__constant int periodicY = {};\n'.format(input['periodicY']))
    f.write('__constant int mirrorN = {};\n'.format(input['mirrorN']))
    f.write('__constant int mirrorS = {};\n'.format(input['mirrorS']))
    f.write('__constant int mirrorE = {};\n'.format(input['mirrorE']))
    f.write('__constant int mirrorW = {};\n\n'.format(input['mirrorW']))
    
    f.write('__constant double ex[{}] = {{'.format(input['Ni']))
    for i in range(input['Ni']):
        if i < input['Ni']-1:
            f.write('{}, '.format(ex[i]))
        else:
            f.write('{}'.format(ex[i]))
    f.write('};\n')
    
    f.write('__constant double ey[{}] = {{'.format(input['Ni']))
    for i in range(input['Ni']):
        if i < input['Ni']-1:
            f.write('{}, '.format(ey[i]))
        else:
            f.write('{}'.format(ey[i]))
    f.write('};\n\n')
    
    f.write('__constant double dx[{}] = {{'.format(input['Nx']))
    for i in range(input['Nx']):
        if i < input['Nx']-1:
            f.write('{}, '.format(dx[i]))
        else:
            f.write('{}'.format(dx[i]))
    f.write('};\n')
    
    f.write('__constant double dy[{}] = {{'.format(input['Ny']))
    for i in range(input['Ny']):
        if i < input['Ny']-1:
            f.write('{}, '.format(dy[i]))
        else:
            f.write('{}'.format(dy[i]))
    f.write('};\n\n')
    
    f.write('__constant unsigned int mirrorNS[13] = {0,1,4,3,2,8,7,6,5,9,12,11,10};\n')
    f.write('__constant unsigned int mirrorEW[13] = {0,3,2,1,4,6,5,8,7,11,10,9,12};\n\n')
    
    f.write('__constant int xx[4] = {-1,1,0,0};\n')
    f.write('__constant int yy[4] = {0,0,-1,1};\n')
    f.write('__constant unsigned    int ii[4][4] = {{1,5,8,9},{3,6,7,11},{2,5,6,10},{4,7,8,12}};\n')
    f.write('__constant unsigned    int inv[4][4] = {{3,6,7,11},{1,5,8,9},{4,7,8,12},{2,5,6,10}};\n')
    
    f.write('/////////////////////////////////////////\n')
    f.write('// DEVICE FUNCTIONS\n')
    f.write('/////////////////////////////////////////\n\n')
    
    f.write('// equilibrium functions for f\n\n')
    
    f.write('double f0(double rho, double u, double v, double T)\n{\n')
    f.write('   //rest particle equilibrium function\n')
    f.write('    return (rho/4.0)*(4.0 + 10.0*T*T + u*u*u*u - 5.0*v*v + v*v*v*v + 10.0*T*(-1.0 + u*u + v*v) + u*u*(-5.0 + 4*v*v));\n}\n\n')
    
    f.write('double f1(double rho, double u, double v, double T)\n{ \n')
    f.write('    return (rho/6.0)*(-6.0*T*T - u*(1.0 + u)*(-4.0 + u*u + 3.0*v*v) - T*(-4.0 + 6.0*u + 9.0*u*u + 3.0*v*v));\n}\n\n')
    
    f.write('double f5(double rho, double u, double v, double T)\n{\n')
    f.write('    return (rho/4.0)*((T + u + u*u)*(T + v + v*v));\n}\n\n')
    
    f.write('double f9(double rho, double u, double v, double T)\n{\n')
    f.write('    return (rho/24.0)*(3.0*T*T + (-1.0 + u)*u*(1.0 + u)*(2.0 + u) + T*(-1.0 + 6.0*u*(1.0 + u)));\n}\n\n')
    
    f.write('// equilibrium functions for h\n\n')
    
    f.write('double h0(double T, double u, double v)\n{\n')
    f.write('    double A = (24.0 + 12.0*K - 120.0*T - 30.0*K*T + 160.0*T*T + 30.0*K*T*T)*T;\n')
    f.write('    double B = 12.0 - T*(120.0 + 15.0*K - 270.0*T - 30.0*K*T);\n')
    f.write('    double C = -15.0 + T*(60.0 + 3.0*K);\n')
    f.write('    double D = -30.0 + T*(180.0 + 12.0*K);\n')
    f.write('return A + B*(u*u + v*v) + C*(u*u*u*u+v*v*v*v) + D*u*u*v*v + 3.0*(u*u + v*v)*(u*u*u*u + 4.0*u*u*v*v + v*v*v*v);\n}\n\n')
    
    f.write('double h1(double T, double u, double v)\n{\n')
    f.write('    double A = (16.0 + 4.0*K - 32.0*T - 6.0*K*T)*T*T;\n')
    f.write('    double B = (16.0 + 4.0*K - 36.0*T - 6.0*K*T)*T;\n')
    f.write('    double C = (28.0 + 4.0*K - 78.0*T - 9.0*K*T)*T;\n')
    f.write('    double D = (4.0 - 30.0*T - 3.0*K*T)*T;\n')
    f.write('    double E = 4.0 - T*(14.0 + K);\n')
    f.write('    double F = 4.0 - T*(30.0 + 3.0*K);\n')
    f.write('    double G = E - 5.0*T;\n')
    f.write('    double H = F - 12.0*T;\n')
    f.write('    double I = -3.0*T;\n')
    f.write('return A + B*u + C*u*u + D*v*v + E*u*u*u + F*u*v*v + G*u*u*u*u + H*u*u*v*v + I*v*v*v*v - u*(u + 1.0)*(u*u + 3.0*v*v)*(u*u + v*v);\n}\n\n')

    
    f.write('double h5(double T, double u, double v)\n{\n')
    f.write('    double A = (16.0 + 3.0*K)*T*T*T;\n')
    f.write('    double B = (18.0 + 3.0*K)*T*T;\n')
    f.write('    double C = (27.0 + 3.0*K)*T*T;\n')
    f.write('    double D = (18.0 + 3.0*K)*T;\n')
    f.write('    double E = 3.0*T;\n')
    f.write('    double F = (27.0 + 3.0*K)*T;\n')
    f.write('    double G = F + 9.0*T;\n')

    f.write('    return A + B*(u + v) + C*(u*u + v*v) + D*u*v + E*(u*u*u + v*v*v + u*u*u*u + v*v*v*v) + F*(u*u*v + u*v*v) + G*u*u*v*v + 3.0*u*v*(v+1.0)*(u+1.0)*(u*u + v*v);\n}\n\n')

    
    f.write('double h9(double T, double u, double v)\n{\n')
    f.write('    double A = (-4.0 - K + 16.0*T + 3.0*K*T)*T*T;\n')
    f.write('    double B = (-8.0 - 2.0*K + 36.0*T + 6.0*K*T)*T;\n')
    f.write('    double C = (-7.0 - K + 51.0*T + 6.0*K*T)*T;\n')
    f.write('    double D = T*(3.0*T - 1.0);\n')
    f.write('    double E = -2.0 + T*(22.0 + 2.0*K);\n')
    f.write('    double F = -2.0 + 6.0*T;\n')
    f.write('    double G = -1.0 + T*(16.0 + K);\n')
    f.write('    double H = F + 1.0;\n')

    f.write('    return A + B*u + C*u*u + D*v*v + E*u*u*u + F*u*v*v +  G*u*u*u*u + H*u*u*v*v + u*u*u*(u + 2)*(u*u + v*v);\n}\n\n')
    
    f.write('////////////////////////////////////////////////////////////////////////////////\n')
    f.write('// clEq2D\n')
    f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
    
    f.write('int clEq2D(double rho, double u_, double v_, double T_, double* eqf, double* eqh)\n{\n')
    f.write('    //returns the equilibrium values for each velocity vector given the current\n')
    f.write('    // macroscopic values and the corresponding reference quantities\n\n')
    
    RTc = input['R']*input['Tc']
    sRTc = sqrt(RTc)
    
    f.write('    double u = u_/{};\n'.format(sRTc))
    f.write('    double v = v_/{};\n'.format(sRTc))
    f.write('    double T = T_/Tc;\n\n')
    #
    f.write('    eqf[0] = f0(rho,u,v,T);\n')
    f.write('    eqf[1] = f1(rho,u,v,T);\n')
    f.write('    eqf[2] = f1(rho,v,u,T);\n')
    f.write('    eqf[3] = f1(rho,-u,v,T);\n')
    f.write('    eqf[4] = f1(rho,-v,u,T);\n')
    f.write('    eqf[5] = f5(rho,u,v,T);\n')
    f.write('    eqf[6] = f5(rho,-u,v,T);\n')
    f.write('    eqf[7] = f5(rho,-u,-v,T);\n')
    f.write('    eqf[8] = f5(rho,u,-v,T);\n')
    f.write('    eqf[9] = f9(rho,u,v,T);\n')
    f.write('    eqf[10] = f9(rho,v,u,T);\n')
    f.write('    eqf[11] = f9(rho,-u,v,T);\n')
    f.write('    eqf[12] = f9(rho,-v,u,T);\n\n')
    #
    f.write('    double rRTc = rho*{};\n\n'.format(RTc))
    #
    f.write('    eqh[0] = rRTc*h0(T,u,v)/24.0;\n')
    f.write('    eqh[1] = rRTc*h1(T,u,v)/12.0;\n')
    f.write('    eqh[2] = rRTc*h1(T,v,u)/12.0;\n')
    f.write('    eqh[3] = rRTc*h1(T,-u,v)/12.0;\n')
    f.write('    eqh[4] = rRTc*h1(T,-v,u)/12.0;\n')
    f.write('    eqh[5] = rRTc*h5(T,u,v)/24.0;\n')
    f.write('    eqh[6] = rRTc*h5(T,-u,v)/24.0;\n')
    f.write('    eqh[7] = rRTc*h5(T,-u,-v)/24.0;\n')
    f.write('    eqh[8] = rRTc*h5(T,u,-v)/24.0;\n')
    f.write('    eqh[9] = rRTc*h9(T,u,v)/48.0;\n')
    f.write('    eqh[10] =rRTc*h9(T,v,u)/48.0;\n')
    f.write('    eqh[11] =rRTc*h9(T,-u,v)/48.0;\n')
    f.write('    eqh[12] =rRTc*h9(T,-v,u)/48.0;\n\n')
    if 0:
        f.write('    //check\n')
        f.write('    double sum_f = 0;\n')
        f.write('    double sum_h = 0;\n')
        f.write('    for (int i = 0; i < 13; i++) {\n')
        f.write('        sum_f += eqf[i];\n')
        f.write('        sum_h += eqh[i];\n')
        f.write('    }\n')
        f.write('    double U = sqrt(u_*u_ + v_*v_);\n')
        f.write('    double E = (U*U + (K+2.0)*R*T_)/2.0;\n\n')
        
        f.write('    double diff1 = sum_h/rho - E;\n')
        f.write('    double diff2 = sum_f - rho;\n\n')
            
        f.write('    int errEq;\n\n')
        
        f.write('    if (diff1 > 1 || diff2 > 1) {\n')
        f.write('            errEq = 1;\n')
        f.write('    }\n')
        f.write('    else {\n')
        f.write('        errEq = 0;\n')
        f.write('    }\n')
        f.write('    return errEq;')
    else:
        f.write('    return 0;')
    f.write('\n}\n\n')
    
    f.write('////////////////////////////////////////////////////////////////////////////////\n')
    f.write('// clMirIndex\n')
    f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
    
    f.write('void\n')
    f.write('clMirIndex(int i, int mir_x, int mir_y, int* i_x, int* i_y)')
    f.write('{\n')
    f.write('    // gives the mirrored index about the axes defined by inputs mir_x, and mir_y\n\n')
    f.write('     // initialise with no mirror\n')
    f.write('     (*i_x) = i;\n')
    f.write('     (*i_y) = i;\n\n')
    f.write('     // mirror about x\n')
    f.write('     if (mir_x == 1) {\n')
    f.write('        (*i_x) = mirrorNS[i];\n')
    f.write('     }\n\n')
    f.write('     // mirror about y\n')
    f.write('     if(mir_y == 1) {\n')
    f.write('        (*i_y) = mirrorEW[i];\n')
    f.write('     }\n')
    f.write('}\n')
    
    f.write('////////////////////////////////////////////////////////////////////////////////\n')
    f.write('// clSign\n')
    f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
    
    f.write('int\n')
    f.write('clSign(double a)\n')
    f.write('{\n')
    f.write('    //returns: a = 0 -> 0, a = neg -> -1, a = pos -> 1\n')
    f.write('     if (a > 0) {\n')
    f.write('    return 1;\n')
    f.write('    }\n')
    f.write('    else if (a < 0) {\n')
    f.write('     return -1;\n')
    f.write('    }\n')
    f.write('    else {\n')
    f.write('         return 0;\n')
    f.write('    }\n')
    f.write('}\n\n')
    
    f.write('////////////////////////////////////////////////////////////////////////////////\n')
    f.write('// clIndex\n')
    f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
    
    f.write('int\n')
    f.write('clIndex(int i, int pm, int d, int* mir)\n')
    f.write('{\n')
    f.write('    // calculate index of next item given current item i and direction pm\n')
    f.write('    // d = 0 -> x\n')
    f.write('    // d = 1 -> y\n\n')
    f.write('    i = i + pm;\n')
    f.write('    (*mir) = 0;\n\n')
    f.write('    if (d == 0) {\n')
    f.write('        if (i < 0) {\n')
    if input['periodicX'] > 0:
        f.write('               i = Nx + i;\n')
    elif input['mirrorW'] > 0:
        f.write('               i = -i - 1;\n')
        f.write('               (*mir) = 1;\n')
    else:
        f.write('               i = 0; //zeroth order extrapolation\n')
    f.write('        }\n')
    f.write('        else if (i > Nx - 1) {\n')
    if input['periodicX'] > 0:
        f.write('                i = i - Nx;\n')
    elif input['mirrorE'] > 0:
        f.write('                i = 2*Nx - i - 1;\n')
        f.write('                (*mir) = 1;\n')
    else:
        f.write('                i = Nx - 1; //zeroth order extrapolation\n')
    f.write('        }\n')
    f.write('    }\n')
    
    f.write('    else if (d == 1) {\n')
    f.write('        if (i < 0) {\n')
    if input['periodicY'] > 0:
        f.write('               i = Ny + i;\n')
    elif input['mirrorS'] > 0:
        f.write('                i = -i - 1;\n')
        f.write('                (*mir) = 1;\n')
    else:
        f.write('                i = 0; //zeroth order extrapolation\n')
    f.write('        }\n')
    f.write('        else if (i > Ny - 1) {\n')
    if input['periodicY'] > 0:
            f.write('                i = i - Ny;\n')
    elif input['mirrorN'] > 0:
        f.write('                i = 2*Ny - i - 1;\n')
        f.write('                (*mir) = 1;\n')
    else:
        f.write('            i = Ny - 1; //zeroth order extrapolation\n')
    f.write('        }\n')
    f.write('    }\n')
    f.write('    return i;\n')
    f.write('}\n\n')
    
    f.write('////////////////////////////////////////////////////////////////////////////////\n')
    f.write('// clStencil\n')
    f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
    
    # stencil size
    if input['FMETHOD'] == 0:
        # NND
        stencil_length = 3
    elif input['FMETHOD'] == 1:
        #WENO5
        stencil_length = 5
    
    #parameter used in this code
    low = (stencil_length - 1) / 2
    
    f.write('void\n')
    f.write('clStencil(__global double* f,\n')
    f.write('    double* Sx,\n')
    f.write('    double* Sy,\n')
    f.write('    int i,\n')
    f.write('    __global int* cell,\n')
    f.write('    __global int* bnd)\n')
    f.write('{\n')
    f.write('    // create a stencil of given length for the Flux method specified\n\n')
    f.write('    if (i == 0) {\n')
    f.write('        return;\n')
    f.write('    }\n\n')
    f.write('    // global index\n')
    f.write('    size_t ix = get_global_id(0);\n')
    f.write('    size_t iy = get_global_id(1);\n\n')
    f.write('    // velocity vector, in integer values for indexing\n')
    f.write('    int exi = clSign(ex[i]);\n')
    f.write('    int eyi = clSign(ey[i]);\n\n')
    f.write('    int low = {};    // max/min num of stencil from centre\n\n'.format(low))
    f.write('    // calculate stencil along x and y\n')
    f.write('    int jx1 = ix - exi*low;        //start of stencil index\n')
    f.write('    int jy1 = iy - eyi*low;\n\n')
    f.write('    int jx, jy, mir_x, mir_y, i_x, i_y;\n\n')
    if input['isSolid'] == 1:
        f.write('    int sld_x = 0;\n')
        f.write('    int sld_y = 0;\n')
        f.write('    int sldx[{}];\n'.format(stencil_length))
        f.write('    int sldy[{}];\n\n'.format(stencil_length))
        f.write('    int id, type;\n\n')
    f.write('    for (int j = 0; j < {}; j++) {{\n'.format(stencil_length))
    f.write('        // put together stencil along axis lines, start on low side, go to hi side: [j-low <-> j+low]\n')
    f.write('        jx = clIndex(jx1,exi*j,0,&mir_y);\n')
    f.write('        jy = clIndex(jy1,eyi*j,1,&mir_x);\n\n')
    f.write('        clMirIndex(i,mir_x,mir_y,&i_x,&i_y);    // mirror indexes if required\n\n')
    if input['isSolid'] == 1:
        f.write('        id = BND(jx,iy);\n')
        f.write('        type = CELL(id);\n')
    f.write('        // x\n')
    f.write('        Sx[j] = F(jx,iy,i_y);\n\n')
    if input['isSolid'] == 1:
        f.write('        if (type == 2) { // if solid\n')
        f.write('            sldx[j] = 1;\n')
        f.write('            sld_x = 1;\n')
        f.write('        }\n')
        f.write('        else {\n')
        f.write('            sldx[j] = 0;\n')
        f.write('        }\n\n')
    f.write('        // y\n')
    f.write('        Sy[j] = F(ix,jy,i_x);\n\n')
    if input['isSolid'] == 1:
        f.write('        if (type == 2) {\n')
        f.write('            sldy[j] = 1;\n')
        f.write('            sld_y = 1;\n')
        f.write('        }\n')
        f.write('        else { \n')
        f.write('            sldy[j] = 0;\n')
        f.write('        }\n')
    f.write('    }\n\n')
    if input['isSolid'] == 1:
        f.write('    int diff;    // difference between indexes of sldx\n')
        f.write('    int x_;    // location of edge solid node, outside coords\n')
        f.write('    int y_;    // location of edge solid node, outside coords\n')
        f.write('    int j_;    // location of edge solid node, stencil coords\n\n')
        f.write('    if (sld_x == 1) {\n')
        f.write('        // find where edge solid node is\n')
        f.write('        for (int j = 0; j < {}; j++) {{\n'.format(stencil_length - 1))
        f.write('            diff = sldx[j] - sldx[j+1];\n')
        f.write('            if (diff > 0) {\n')
        f.write('                j_ = j;\n')
        f.write('                x_ = clIndex(jx1,exi*j,0,&mir_y);\n')
        f.write('                break;\n')
        f.write('            }\n')
        f.write('            else if (diff < 0) {\n')
        f.write('                j_ = j + 1;\n')
        f.write('                x_ = clIndex(jx1,exi*(j + 1),0,&mir_y);\n')
        f.write('                break;\n')
        f.write('            }\n')
        f.write('        }\n\n')
        f.write('        // update solid part of stencil with linear extrapolation of actual stencil\n\n')
        f.write('        int xm1 = clIndex(x_,exi*diff,0,&mir_y);    // closest fluid node\n')
        f.write('        int xm2 = clIndex(x_,exi*2*diff,0,&mir_y);    // next closest fluid node\n\n')
        f.write('        Sx[j_] = 2*F(xm1,iy,i) - F(xm2,iy,i);\n\n')
        f.write('        int j__ = j_ - diff;\n\n')
        f.write('        if (j__ >= 0 && j__ < {}) {{ // update next one along if stencil is long enough\n'.format(stencil_length))
        f.write('            Sx[j__] = Sx[j_];\n')
        f.write('        }\n')
        f.write('    }\n\n')
        f.write('    if (sld_y == 1) {\n\n')
        f.write('        // find where edge solid node is\n')
        f.write('        for (int j = 0; j < {}; j++) {{\n'.format(stencil_length - 1))
        f.write('            diff = sldy[j] - sldy[j+1];\n')
        f.write('            if (diff > 0) {\n')
        f.write('                j_ = j;\n')
        f.write('                y_ = clIndex(jy1,eyi*j,1,&mir_x);\n')
        f.write('                break;\n')
        f.write('            }\n')
        f.write('            else if (diff < 0) {\n')
        f.write('                j_ = j + 1;\n')
        f.write('                y_ = clIndex(jy1,eyi*(j + 1),1,&mir_x);\n')
        f.write('                break;\n')
        f.write('            }\n')
        f.write('        }\n\n')
        f.write('        // update solid part of stencil with linear extrapolation of actual stencil\n\n')
        f.write('        int ym1 = clIndex(y_,eyi*diff,0,&mir_x);    // closest fluid node\n')
        f.write('        int ym2 = clIndex(y_,eyi*2*diff,0,&mir_x);    // next closest fluid node\n\n')
        f.write('        Sy[j_] = 2*F(ix,ym1,i) - F(ix,ym2,i);\n\n')
        f.write('        int j__ = j_ - diff;\n\n')
        f.write('        if (j__ >= 0 && j__ < {}) {{    // update next one along if stencil is long enough\n'.format(stencil_length))
        f.write('            Sy[j__] = Sy[j_];\n')
        f.write('        }\n')
        f.write('    }\n')
    f.write('}\n\n')
        
    if input['FMETHOD'] == 0:
        f.write('////////////////////////////////////////////////////////////////////////////////\n')
        f.write('// clMinMod\n')
        f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
        
        f.write('double\n')
        f.write('clMinmod(double a, double b)\n')
        f.write('{\n')
        f.write('    // calculate minmod function\n\n')
        f.write('   double out;\n\n')
        f.write('   if ((fabs(a) < fabs(b)) && (a*b > 0))\n')
        f.write('       out = a;\n')
        f.write('    else if ((fabs(b) < fabs(a)) && (a*b > 0))\n')
        f.write('       out = b;\n')
        f.write('    else if (a == b)\n')
        f.write('       out = a;\n')
        f.write('    else if (a*b <= 0)\n')
        f.write('       out = 0;\n')
        f.write('    return out;\n')
        f.write('}\n\n')
    
        f.write('////////////////////////////////////////////////////////////////////////////////\n')
        f.write('// clNND\n')
        f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
        
        f.write('double\n')
        f.write('clNND(double* S, double e)\n')
        f.write('{\n')
        f.write('   // calculate the flux by the NND method (2nd order accurate, CFL_max = 2/3)\n\n')
        f.write('    double Fp_I, Fp_Ip1, Fp_Im1;\n\n')
        f.write('    double vP = fabs(e);\n\n')
        f.write('    if (vP == 0) {\n')
        f.write('        return 0;\n')
        f.write('    }\n\n')
        f.write('    Fp_I   = vP*S[1];\n')
        f.write('    Fp_Ip1 = vP*S[2];\n')
        f.write('    Fp_Im1 = vP*S[0];\n\n')
        f.write('    double dFp_Ip12, dFp_Im12;\n\n')
        f.write('    dFp_Ip12 = Fp_Ip1 - Fp_I;\n')
        f.write('    dFp_Im12 = Fp_I - Fp_Im1;\n\n')
        f.write('    double F_Ip12;\n\n')
        f.write('    F_Ip12 = Fp_I + 0.5*clMinmod(dFp_Ip12,dFp_Im12);\n\n')
        f.write('    return F_Ip12;\n')
        f.write('}\n\n')
    
    if input['FMETHOD'] == 1:
        f.write('////////////////////////////////////////////////////////////////////////////////\n')
        f.write('// clWENO5\n')
        f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
        
        f.write('double\n')
        f.write('clWENO5(double* S, double e)\n')
        f.write('{\n')
        f.write('    // calculate the flux term of the WENO5 scheme for one flow direction\n\n')
        f.write('    double epsilon = (double) 1e-6;\n')
        f.write('    double posFlow = fabs(e);\n')
        f.write('    double F_Ip12;\n\n')
        f.write('    if (posFlow == 0) {\n')
        f.write('        return 0;\n')
        f.write('    }\n')
        f.write('    else {\n')
        f.write('        double Sp[5];\n')
        f.write('        for (int i = 0; i < 5; i++) {\n')
        f.write('            Sp[i] = S[i]*posFlow;\n')
        f.write('        }\n\n')
        f.write('        double B0p, B1p, B2p, alpha0p, alpha1p, alpha2p;\n')
        f.write('        double omega0p, omega1p, omega2p, f0p, f1p, f2p, temp1, temp2;\n\n')
        
        f.write('        temp1 = Sp[0] - 2.0*Sp[1] + Sp[2];\n')
        f.write('        temp2 = Sp[0] - 4.0*Sp[1] + 3.0*Sp[2];\n')
        f.write('        B0p = {}*temp1*temp1 + {}*temp2*temp2;\n'.format(13.0/12.0,1.0/4.0))
        
        f.write('        temp1 = Sp[1] - 2.0*Sp[2] + Sp[3];\n')
        f.write('        temp2 = Sp[1] - Sp[3];\n')
        f.write('        B1p = {}*temp1*temp1 + {}*temp2*temp2;\n'.format(13.0/12.0,1.0/4.0))
        
        f.write('        temp1 = Sp[2] - 2.0*Sp[3] + Sp[3];\n')
        f.write('        temp2 = 3.0*Sp[2] - 4.0*Sp[3] + Sp[4];\n')
        f.write('        B2p = {}*temp1*temp1 + {}*temp2*temp2;\n\n'.format(13.0/12.0,1.0/4.0))
        
        f.write('        temp1 = 1.0/(epsilon + B0p);\n')
        f.write('        alpha0p = {}*temp1*temp1;\n'.format(1.0/10.0))
        
        f.write('        temp1 = 1.0/(epsilon + B1p);\n')
        f.write('        alpha1p = {}*temp1*temp1;\n'.format(6.0/10.0))
        
        f.write('        temp1 = 1.0/(epsilon + B2p);\n')
        f.write('        alpha2p = {}*temp1*temp1;\n\n'.format(3.0/10.0))
        
        f.write('        omega0p = alpha0p/(alpha0p + alpha1p + alpha2p);\n')
        f.write('        omega1p = alpha1p/(alpha0p + alpha1p + alpha2p);\n')
        f.write('        omega2p = alpha2p/(alpha0p + alpha1p + alpha2p);\n\n')
        f.write('        f0p = {}*Sp[0] - {}*Sp[1] + {}*Sp[2];\n'.format(2.0/6.0,7.0/6.0,11.0/6.0))
        f.write('        f1p = -{}*Sp[1] + {}*Sp[2] + {}*Sp[3];\n'.format(1.0/6.0,5.0/6.0,2.0/6.0))
        f.write('        f2p = {}*Sp[2] + {}*Sp[3] - {}*Sp[4];\n\n'.format(2.0/6.0,5.0/6.0,1.0/6.0))
        f.write('        F_Ip12 = omega0p*f0p + omega1p*f1p + omega2p*f2p;\n\n')
        f.write('    }\n\n')
        f.write('    return F_Ip12;\n')
        f.write('}\n\n')
    
    f.write('////////////////////////////////////////////////////////////////////////////////\n')
    f.write('// clFLUX\n')
    f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
    
    f.write('void\n')
    f.write('clFLUX(__global double* f, int i, __global int* cell, __global int* bnd, double* flux_x, double* flux_y)\n')
    f.write('{\n')
    f.write('    // choose flux method\n\n')
    f.write('    double exi, eyi;\n\n')
    f.write('    exi = ex[i];\n')
    f.write('    eyi = ey[i];\n\n')
    f.write('    // calculate area of flux\n')
    f.write('    double areaX = dy[i]; // assume dz = 1\n')
    f.write('    double areaY = dx[i];\n')
    if input['FMETHOD'] == 0:
        f.write('    //NND\n')
        f.write('    double Sx[3];\n')
        f.write('    double Sy[3];\n\n')
        f.write('    clStencil(f, Sx, Sy, i, cell, bnd);\n\n')
        f.write('    (*flux_x) = areaX*clNND(Sx,exi);\n')
        f.write('    (*flux_y) = areaY*clNND(Sy,eyi);\n\n')
    elif input['FMETHOD'] == 1:
        f.write('    // WENO5\n')
        f.write('    double Sx[5];\n')
        f.write('    double Sy[5];\n\n')
        f.write('    clStencil(f, Sx, Sy, i, cell, bnd);\n\n')
        f.write('    (*flux_x) = areaX*clWENO5(Sx, exi);\n')
        f.write('    (*flux_y) = areaY*clWENO5(Sy, eyi);\n\n')
    f.write('}\n\n')
    
    f.write('////////////////////////////////////////////////////////////////////////////////\n')
    f.write('// clCombineFLUX\n')
    f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
    
    f.write('#define FLUX_X(x,y,i) flux_x[x*Ni*Ny + y*Ni + i]\n')
    f.write('#define FLUX_Y(x,y,i) flux_y[x*Ni*Ny + y*Ni + i]\n')
    
    f.write('double\n')
    f.write('clCombineFLUX(__global double* flux_x, __global double* flux_y, int i)\n')
    f.write('{\n')
    f.write('    // calculates the combined flux given all the fluxes out of each node, input is kg/s, output is kg/m^3\n\n')
    f.write('    if (i == 0) {\n\n')
    f.write('        return 0;\n')
    f.write('    }\n')
    f.write('    else {\n')
    f.write('        // global index\n')
    f.write('        size_t ix = get_global_id(0);\n')
    f.write('        size_t iy = get_global_id(1);\n\n')
    f.write('        // velocity vector, in integer values for indexing\n')
    f.write('        int exi = clSign(ex[i]);\n')
    f.write('        int eyi = clSign(ey[i]);\n\n')
    f.write('        int mir_x, mir_y;\n\n')
    f.write('        int x_ = clIndex(ix,-exi,0,&mir_y);\n')
    f.write('        int y_ = clIndex(iy,-eyi,1,&mir_x);\n\n')
    f.write('        // calculate volume of current cell\n')
    f.write('        double vol = dx[ix]*dy[iy];\n\n')
    f.write('        int i_x, i_y;\n\n')
    f.write('        clMirIndex(i,mir_x,mir_y,&i_x,&i_y);    // mirror indexes if required\n\n')
    #f.write('        double flux_out = dt*(FLUX_X(ix,iy,i)/(dx[ix]*vol) + FLUX_Y(ix,iy,i)/(dy[iy]*vol));\n\n')
    #f.write('        double flux_in =  dt*(FLUX_X(x_,iy,i_y)/(dx[ix]*vol) + FLUX_Y(ix,y_,i_x)/(dy[iy]*vol));\n\n')
    f.write('        double flux_out = FLUX_X(ix,iy,i)  +  FLUX_Y(ix,iy,i);\n\n')
    f.write('        double flux_in =  FLUX_X(x_,iy,i_y) + FLUX_Y(ix,y_,i_x);\n\n')
    f.write('        return (flux_out - flux_in)*(dt/vol);\n')
    f.write('    }\n')
    f.write('}\n\n')
    
    f.write('////////////////////////////////////////////////////////////////////////////////\n')
    f.write('// clPosFlux\n')
    f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
        
    f.write('void\n')
    f.write('clPosFlux(__global double* f,\n')
    f.write('    __global double* h,\n')
    f.write('    int i,\n')
    f.write('    __global int* cell,\n')
    f.write('    __global int* bnd,\n')
    f.write('    __global double* f_flux_x,\n')
    f.write('    __global double* f_flux_y,\n')
    f.write('    __global double* h_flux_x,\n')
    f.write('    __global double* h_flux_y)\n')
    f.write('{\n')
    f.write('    // function to calculate all positive fluxes along axis (x & y) lines for fluid nodes\n')
    f.write('    // store fluxes in global memory, fluxes given in kg\n\n')
    f.write('    // global index\n')
    f.write('    size_t ix = get_global_id(0);\n')
    f.write('    size_t iy = get_global_id(1);\n\n')
    f.write('    int id = BND(ix,iy);\n')
    f.write('    int type = CELL(id);\n\n')
    f.write('    if (type != 2) {    // only perform fluxes on fluid and permanent nodes\n')
    f.write('        double flux_fx, flux_fy, flux_hx, flux_hy;\n\n')
    f.write('        clFLUX(f,i,cell,bnd,&flux_fx,&flux_fy);\n')
    f.write('        clFLUX(h,i,cell,bnd,&flux_hx,&flux_hy);\n\n')
    f.write('        // store fluxes in global memory\n')
    f.write('        F_FLUX_X(ix,iy,i) = flux_fx;\n')
    f.write('        F_FLUX_Y(ix,iy,i) = flux_fy;\n\n')
    f.write('        H_FLUX_X(ix,iy,i) = flux_hx;\n')
    f.write('        H_FLUX_Y(ix,iy,i) = flux_hy;\n')
    f.write('    }\n')
    f.write('}\n\n')
    
    
    f.write('////////////////////////////////////////////////////////////////////////////////\n')
    f.write('// clMacroProp\n')
    f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
    
    f.write('#define RHO(x,y) rho[x*Ny + y] \n')
    f.write('#define UX(x,y) ux[x*Ny + y] \n')
    f.write('#define UY(x,y) uy[x*Ny + y] \n')
    f.write('#define T(x,y)  T[x*Ny + y] \n')
    
    f.write('__kernel void\n')
    f.write('clMacroProp(__global double* f,\n')
    f.write('    __global double* h,\n')
    f.write('    __global double* rho,\n')
    f.write('    __global double* ux,\n')
    f.write('    __global double* uy,\n')
    f.write('    __global double* T)\n')
    f.write('{\n')
    f.write('    // calculate macroscopic properties\n\n')
    
    f.write('    // global index\n')
    f.write('    size_t ix = get_global_id(0);\n')
    f.write('    size_t iy = get_global_id(1);\n\n')
    
    f.write('    double rho_ = 0.0;\n')
    f.write('    double rho_ux = 0.0;\n')
    f.write('    double rho_uy = 0.0;\n')
    f.write('    double sum_h = 0.0;\n')
    f.write('    double ux_, uy_, T_;\n\n')
    
    f.write('    for (int i = 0; i < Ni; i++) {\n')
    f.write('        rho_    += F(ix,iy,i);\n')
    f.write('        rho_ux += F(ix,iy,i)*ex[i];\n')
    f.write('        rho_uy += F(ix,iy,i)*ey[i];\n')
    f.write('        sum_h  += H(ix,iy,i);\n')
    f.write('    }\n')
    
    f.write('    ux_ = rho_ux/rho_;\n')
    f.write('    uy_ = rho_uy/rho_;\n\n')
    
    f.write('    double ux_abs, uy_abs, usq;\n\n')
    
    f.write('    ux_abs = fabs(ux_);\n')
    f.write('    uy_abs = fabs(uy_);\n')
    
    f.write('    usq = ux_abs*ux_abs + uy_abs*uy_abs;\n')
    
    f.write('    T_ = 2.0*(sum_h/rho_ - usq/2.0)/(b*R);\n\n')
    
    f.write('    // assign variables to arrays\n')
    f.write('    RHO(ix,iy) = rho_;\n')
    f.write('    UX(ix,iy) = ux_;\n')
    f.write('    UY(ix,iy) = uy_;\n')
    f.write('    T(ix,iy) = T_;\n')
    f.write('}\n\n')
    
    if input['RKMETHOD'] == 1:
        f.write('////////////////////////////////////////////////////////////////////////////////\n')
        f.write('// clMacroProp3\n')
        f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
        
        f.write('#define RHO_3(x,y) rho_3[x*Ny + y] \n')
        f.write('#define UX_3(x,y) ux_3[x*Ny + y] \n')
        f.write('#define UY_3(x,y) uy_3[x*Ny + y] \n')
        f.write('#define T_3(x,y)  T_3[x*Ny + y] \n\n')
        
        f.write('__kernel void\n')
        f.write('clMacroProp3(__global double* f,\n')
        f.write('    __global double* h,\n')
        f.write('    __global double* rho_3,\n')
        f.write('    __global double* ux_3,\n')
        f.write('    __global double* uy_3,\n')
        f.write('    __global double* T_3,')
        f.write('    __global double* f_flux_x2,\n')
        f.write('    __global double* f_flux_y2,\n')
        f.write('    __global double* h_flux_x2,\n')
        f.write('    __global double* h_flux_y2)\n')
        f.write('{\n')
        f.write('    //perform RK3 step 3 macroscopic properties calculation\n\n')
        f.write('    // global index\n')
        f.write('    size_t ix = get_global_id(0);\n')
        f.write('    size_t iy = get_global_id(1);\n\n')
        f.write('    double rho_ = 0.0;\n')
        f.write('    double rho_ux = 0.0;\n')
        f.write('    double rho_uy = 0.0;\n')
        f.write('    double sum_h = 0.0;\n')
        f.write('    double ux_, uy_, T_, flux_f, flux_h;\n\n')
        
        f.write('    for (int i = 0; i < Ni; i++) {\n')
        f.write('        //calculate fluxes\n')
        f.write('        flux_f = clCombineFLUX(f_flux_x2, f_flux_y2, i);\n')
        f.write('        flux_h = clCombineFLUX(h_flux_x2, h_flux_y2, i);\n\n')
        f.write('        rho_    += F(ix,iy,i) - flux_f;\n')
        f.write('        rho_ux  += (F(ix,iy,i) - flux_f)*ex[i];\n')
        f.write('        rho_uy  += (F(ix,iy,i) - flux_f)*ey[i];\n')
        f.write('        sum_h   += H(ix,iy,i) - flux_h;\n')
        f.write('    }\n')
        
        f.write('    ux_ = rho_ux/rho_;\n')
        f.write('    uy_ = rho_uy/rho_;\n\n')
        
        f.write('    double ux_abs, uy_abs, usq;\n\n')
        
        f.write('    ux_abs = fabs(ux_);\n')
        f.write('    uy_abs = fabs(uy_);\n')
        
        f.write('    usq = ux_abs*ux_abs + uy_abs*uy_abs;\n')
        
        f.write('    T_ = 2.0*(sum_h/rho_ - usq/2.0)/(b*R);\n\n')
        
        f.write('    // assign variables to arrays\n')
        f.write('    RHO_3(ix,iy) = rho_;\n')
        f.write('    UX_3(ix,iy) = ux_;\n')
        f.write('    UY_3(ix,iy) = uy_;\n')
        f.write('    T_3(ix,iy) = T_;\n')
        f.write('}\n\n')
    
    f.write('////////////////////////////////////////////////////////////////////////////////\n')
    f.write('// KERNEL: initFunctions\n')
    f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
    
    f.write('// KERNEL FUNCTION\n')
    f.write('__kernel void\n')
    f.write('initFunctions(__global double* f_G,\n')
    f.write('    __global double* h_G,\n')
    f.write('    __global int* bnd,\n')
    f.write('    __global double* density,\n')
    f.write('    __global double* velX,\n')
    f.write('    __global double* velY,\n')
    f.write('    __global double* therm,\n')
    f.write('    __global double* rho_G,\n')
    f.write('    __global double* ux_G,\n')
    f.write('    __global double* uy_G,\n')
    f.write('    __global double* T_G) {\n')
    f.write('    // initialise functions\n\n')
    
    f.write('    // global index\n')
    f.write('    size_t ix = get_global_id(0);\n')
    f.write('    size_t iy = get_global_id(1);\n\n')
    
    f.write('    int id = BND(ix,iy);\n\n')
    
    f.write('    double rho = DENSITY(id);\n')
    f.write('    double ux = VELX(id);\n')
    f.write('    double uy = VELY(id);\n')
    f.write('    double T = THERM(id);\n\n')
    
    f.write('    double eqf[Ni];\n')
    f.write('    double eqh[Ni];\n\n')
    
    f.write('    // compute equilibrium functions\n')
    f.write('    clEq2D(rho, ux, uy, T, eqf, eqh);\n')
    
    f.write('    for (int i = 0; i < Ni; i++) {\n')
    f.write('        F_G(ix,iy,i) = eqf[i];\n')
    f.write('        H_G(ix,iy,i) = eqh[i];\n')
    f.write('    }\n\n')
    
    f.write('    clMacroProp(f_G, h_G, rho_G, ux_G, uy_G, T_G);\n')
    f.write('}')
    
    f.write('////////////////////////////////////////////////////////////////////////////////\n')
    f.write('//KERNEL: GLOBAL_FLUXES\n')
    f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
    
    f.write('__kernel void\n')
    f.write('GLOBAL_FLUXES(__global double* f,\n')
    f.write('    __global double* h,\n')
    f.write('    __global int* cell,\n')
    f.write('    __global int* bnd,\n')
    f.write('    __global double* f_flux_x,\n')
    f.write('    __global double* f_flux_y,\n')
    f.write('    __global double* h_flux_x,\n')
    f.write('    __global double* h_flux_y)\n')
    f.write('{\n')
    f.write('    // calculate all outgoing fluxes for the given distribution functions and save to global memory.\n\n')
    f.write('    for (int i = 0; i < Ni; i++) {\n\n')
    f.write('        // calc fluxes, save to global\n')
    f.write('        clPosFlux(f, h, i, cell, bnd, f_flux_x, f_flux_y, h_flux_x, h_flux_y);\n')
    f.write('    }\n')
    f.write('}\n')
    
    if input['isSolid'] == 1:
        f.write('////////////////////////////////////////////////////////////////////////////////\n')
        f.write('//KERNEL: WALL_FLUXES\n')
        f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
        
        f.write('__kernel void \n')
        f.write('WALL_FLUXES(__global double* f_flux_x,\n')
        f.write('    __global double* f_flux_y,\n')
        f.write('    __global double* h_flux_x,\n')
        f.write('    __global double* h_flux_y,\n')
        f.write('    __global int* cell,\n')
        f.write('    __global int* bnd,\n')
        f.write('    __global double* therm,\n')
        f.write('    __global double* velX,\n')
        f.write('    __global double* velY)\n')
        f.write('{\n')
        f.write('    // calculate fluxes into solid nodes and set fluxes out of solid to cancel them out\n\n')
        f.write('    // global index\n')
        f.write('    size_t ix = get_global_id(0);\n')
        f.write('    size_t iy = get_global_id(1);\n\n')
        f.write('    int xm1, ym1, i, inv_i;\n')
        f.write('    int mir_x, mir_y;\n\n')
        f.write('    double flux_in, flux_out, alpha;\n\n')
        f.write('    double feqW[Ni];\n')
        f.write('    double heqW[Ni];\n\n')
        f.write('    double ux, uy;\n')
        f.write('    int inx,iny;\n')
        f.write('    int id = BND(ix,iy);\n')
        f.write('    int type = CELL(id);\n\n')
        f.write('    if ( type == 2) {    //wall nodes\n\n')
        f.write('        flux_in = 0;\n')
        f.write('        flux_out = 0;\n\n')
        f.write('        // calculate volume of wall cell\n')
        f.write('        double volWall = dx[ix]*dy[iy];\n\n')
        f.write('        // calculate area of flux\n')
        f.write('        double areaX = dy[i]; // assume dz = 1\n')
        f.write('        double areaY = dx[i];\n')
        f.write('        clEq2D(1.0, VELX(id), VELY(id), THERM(id), feqW, heqW);\n\n')
        f.write('        // check surrounds for fluid node\n')
        f.write('        for (int j = 0; j < 4; j++) {\n')
        f.write('            xm1 = clIndex(ix,xx[j],0,&mir_y);\n')
        f.write('            ym1 = clIndex(iy,yy[j],1,&mir_x);\n\n')
        f.write('            id = BND(xm1,ym1);\n')
        f.write('            type = CELL(id);\n\n')
        f.write('            if (type != 2) { // if fluid\n\n')
        f.write('                for (int k = 0; k < 4; k++) {\n')
        f.write('                    i = ii[j][k];    // index of velocities into solid\n')
        f.write('                    inv_i = inv[j][k];    // inverted velocities, out of solid\n\n')
        f.write('                    // switches for turning off velocities that don\'t impinge on solid, or leave solid, through the cell pointed to by xx & yy\n')
        f.write('                    inx = abs(xx[j]);    \n')
        f.write('                    iny = abs(yy[j]);\n\n')
        f.write('                    flux_in += inx*F_FLUX_X(xm1,ym1,i) + iny*F_FLUX_Y(xm1,ym1,i);        // flux into solid - kg/s\n\n')
        f.write('                    // absolute value of velocities\n')
        f.write('                    ux = fabs(ex[inv_i]);    \n')
        f.write('                    uy = fabs(ey[inv_i]);\n\n')
        f.write('                    flux_out += inx*feqW[inv_i]*ux*areaX + iny*feqW[inv_i]*uy*areaY;                // flux out of solid, back along inverse velocity\n')
        f.write('                }\n')
        f.write('            }\n')
        f.write('        }\n\n')
        f.write('        alpha = flux_in/flux_out;    // correction factor to equalise flux in to flux out\n\n')
        f.write('        // load required fluxes into flux array\n')
        f.write('        for (int i = 0; i < 13; i++) {\n')
        f.write('            ux = fabs(ex[i]);    \n')
        f.write('            uy = fabs(ey[i]);\n\n')
        f.write('             F_FLUX_X(ix,iy,i) = alpha*ux*feqW[i]*areaX;\n')
        f.write('             F_FLUX_Y(ix,iy,i) = alpha*uy*feqW[i]*areaY;\n\n')
        f.write('             H_FLUX_X(ix,iy,i) = alpha*ux*heqW[i]*areaX;\n')
        f.write('             H_FLUX_Y(ix,iy,i) = alpha*uy*heqW[i]*areaY;\n')
        f.write('        }\n')
        f.write('    }\n')
        f.write('}\n')
    
    if input['RKMETHOD'] == 0:
        f.write('////////////////////////////////////////////////////////////////////////////////\n')
        f.write('//KERNEL: RK1_STEP1\n')
        f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
        
        f.write('// macros for RK1\n')
        f.write('#define FR1(x,y,i) fr1[x*Ny*Ni + y*Ni + i]\n')
        f.write('#define HR1(x,y,i) hr1[x*Ny*Ni + y*Ni + i]\n')
        
        f.write('__kernel void\n')
        f.write('RK1_STEP1(__global double* f_G,\n')
        f.write('    __global double* fr1,\n')
        f.write('    __global double* h_G,\n')
        f.write('    __global double* hr1,\n')
        f.write('    __global int* cell,\n')
        f.write('    __global int* bnd,\n')
        f.write('    __global double* therm,\n')
        f.write('    __global double* velX,\n')
        f.write('    __global double* velY,\n')
        f.write('    __global double* rho_G,\n')
        f.write('    __global double* ux_G,\n')
        f.write('    __global double* uy_G,\n')
        f.write('    __global double* T_G)\n')
        f.write('{\n')
        f.write('    //perform RK1 stepping\n\n')
        f.write('    // global index\n')
        f.write('    size_t ix = get_global_id(0);\n')
        f.write('    size_t iy = get_global_id(1);\n\n')
        f.write('    double rho = RHO_G(ix,iy);\n')
        f.write('    double ux = UX_G(ix,iy);\n')
        f.write('    double uy = UY_G(ix,iy);\n')
        f.write('    double T = T_G(ix,iy);\n\n')
        f.write('    double feq[Ni];\n')
        f.write('    double heq[Ni];\n\n')
        f.write('    int id = BND(ix,iy);\n')
        f.write('    int type = CELL(id);\n\n')
        f.write('    // --- RK STEP ONE----\n')
        f.write('    // calculate the first stage updated distribution functions \n\n')
        f.write('    if (type > 0) {   // check if node is solid or permanent, if it is, just propogate values\n')
        f.write('        for (int i = 0; i < Ni; i++) {\n')
        f.write('            FR1(ix,iy,i) = F_G(ix,iy,i);\n')
        f.write('            HR1(ix,iy,i) = H_G(ix,iy,i);\n')
        f.write('        }\n')
        f.write('    }\n')
        f.write('    else {\n')
        f.write('        // calculate relaxation times from macroscopic properties\n')
        f.write('        double mu_ = mu*powr(T/T_ref,3.0/2.0)*((T_ref+S_v)/(T + S_v));\n')
        f.write('        double tauf = mu_/(rho*R*T);\n')
        f.write('        double tauh = tauf/Pr;\n')
        f.write('        double tauhf = (tauh*tauf)/(tauf - tauh);\n\n')
        f.write('        clEq2D(rho, ux, uy, T, feq, heq);\n\n')
        f.write('        double f1_, edotu;\n')
        f.write('        for (int i = 0; i < Ni; i++) {\n')
        f.write('            // temp variables\n')
        f.write('            f1_ = (F_G(ix,iy,i) + (dt/tauf)*feq[i])/(1.0 + dt/tauf);    //calc to temp variable first, for use later\n\n')
        f.write('            FR1(ix,iy,i) = f1_;        // save to global\n\n')
        f.write('            // temp variables\n')
        f.write('            edotu = ex[i]*ux + ey[i]*uy;\n\n')
        f.write('            HR1(ix,iy,i) = (H_G(ix,iy,i) - dt*edotu*((feq[i] - f1_)/tauhf) + (dt/tauh)*heq[i])/(1.0 + dt/tauh);\n')
        f.write('        }\n')
        f.write('    }\n')
        f.write('}\n\n')
        
        f.write('////////////////////////////////////////////////////////////////////////////////\n')
        f.write('//KERNEL: RK1_COMBINE\n')
        f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
        
        f.write('__kernel void\n')
        f.write('RK1_COMBINE(__global double* f_G,\n')
        f.write('    __global double* fr1,\n')
        f.write('    __global double* h_G,\n')
        f.write('    __global double* hr1,\n')
        f.write('    __global int* cell,\n')
        f.write('    __global int* bnd,\n')
        f.write('    __global double* therm,\n')
        f.write('    __global double* velX,\n')
        f.write('    __global double* velY,\n')
        f.write('    __global double* rho_G,\n')
        f.write('    __global double* ux_G,\n')
        f.write('    __global double* uy_G,\n')
        f.write('    __global double* T_G,\n')
        f.write('    __global double* fr1_flux_x,\n')
        f.write('    __global double* fr1_flux_y,\n')
        f.write('    __global double* hr1_flux_x,\n')
        f.write('    __global double* hr1_flux_y)\n')
        f.write('{\n')
        f.write('    //combine step of RK1\n')
        f.write('\n')
        f.write('    // global index\n')
        f.write('    size_t ix = get_global_id(0);\n')
        f.write('    size_t iy = get_global_id(1);\n\n')
        f.write('    // macroscopic properties\n')
        f.write('    double rho = RHO_G(ix,iy);\n')
        f.write('    double ux = UX_G(ix,iy);\n')
        f.write('    double uy = UY_G(ix,iy);\n')
        f.write('    double T = T_G(ix,iy);\n\n')
        f.write('    // calculate relaxation times from macroscopic properties\n')
        f.write('    double mu_ = mu*powr(T/T_ref,3.0/2.0)*((T_ref+S_v)/(T + S_v));\n')
        f.write('    double tauf = mu_/(rho*R*T);\n')
        f.write('    double tauh = tauf/Pr;\n')
        f.write('    double tauhf = (tauh*tauf)/(tauf - tauh);\n\n')
        f.write('    double feq[Ni];\n')
        f.write('    double heq[Ni];\n\n')
        f.write('    clEq2D(rho, ux, uy, T, feq, heq);\n\n')
        f.write('    double flux_f, flux_h, edotu;\n\n')
        f.write('    int id = BND(ix,iy);\n')
        f.write('    int type = CELL(id);\n\n')
        f.write('        // --- RK COMBINATION ----\n')
        f.write('        // calculate the updated distribution functions\n')
        f.write('    if (type == 0) {\n')
        f.write('        for (int i = 0; i < Ni; i++) {\n')
        f.write('            flux_f = clCombineFLUX(fr1_flux_x, fr1_flux_y, i);\n\n')
        f.write('            F_G(ix,iy,i) = F_G(ix,iy,i) - flux_f + (dt/tauf)*(feq[i] - FR1(ix,iy,i));\n\n')
        f.write('            flux_h = clCombineFLUX(hr1_flux_x,hr1_flux_y, i);\n\n')
        f.write('            edotu = ex[i]*ux + ey[i]*uy;\n\n')
        f.write('            H_G(ix,iy,i) = H_G(ix,iy,i) - flux_h + (dt/tauh)*(heq[i] - HR1(ix,iy,i)) - ((dt*edotu)/tauhf)*(feq[i] - FR1(ix,iy,i));\n')
        f.write('        }\n')
        f.write('    }\n')
        f.write('    // update macro properties\n')
        f.write('    clMacroProp(f_G, h_G, rho_G, ux_G, uy_G, T_G);\n')
        f.write('}\n\n')
        
    if input['RKMETHOD'] == 1:
        
        f.write('////////////////////////////////////////////////////////////////////////////////\n')
        f.write('//KERNEL: RK3_STEP1\n')
        f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
        
        f.write('// macros for RK3\n')
        f.write('#define FR1(x,y,i) fr1[x*Ny*Ni + y*Ni + i]\n')
        f.write('#define HR1(x,y,i) hr1[x*Ny*Ni + y*Ni + i]\n')
        
        f.write('__kernel void\n')
        f.write('RK3_STEP1(__global double* f_G,\n')
        f.write('    __global double* fr1,\n')
        f.write('    __global double* h_G,\n')
        f.write('    __global double* hr1,\n')
        f.write('    __global int* cell,\n')
        f.write('    __global int* bnd,\n')
        f.write('    __global double* therm,\n')
        f.write('    __global double* velX,\n')
        f.write('    __global double* velY,\n')
        f.write('    __global double* rho_G,\n')
        f.write('    __global double* ux_G,\n')
        f.write('    __global double* uy_G,\n')
        f.write('    __global double* T_G)\n')
        f.write('{\n')
        f.write('    //perform RK3 stepping\n')
        f.write('\n')
        f.write('    // global index\n')
        f.write('    size_t ix = get_global_id(0);\n')
        f.write('    size_t iy = get_global_id(1);\n\n')
        f.write('    // macroscopic properties\n')
        f.write('    double rho = RHO_G(ix,iy);\n')
        f.write('    double ux = UX_G(ix,iy);\n')
        f.write('    double uy = UY_G(ix,iy);\n')
        f.write('    double T = T_G(ix,iy);\n\n')
        f.write('    // calculate relaxation times from macroscopic properties\n')
        f.write('    double mu_ = mu*powr(T/T_ref,3.0/2.0)*((T_ref+S_v)/(T + S_v));\n')
        f.write('    double tauf = mu_/(rho*R*T);\n')
        f.write('    double tauh = tauf/Pr;\n')
        f.write('    double tauhf = (tauh*tauf)/(tauf - tauh);\n\n')
        f.write('    double feq[Ni];\n')
        f.write('    double heq[Ni];\n\n')
        f.write('    clEq2D(rho, ux, uy, T, feq, heq);\n\n')
        f.write('    int id = BND(ix,iy);\n')
        f.write('    int type = CELL(id);\n\n')
        f.write('    // --- RK STEP ONE----\n')
        f.write('    // calculate the first stage updated distribution functions \n')
        f.write('    if (type > 0) {\n')
        f.write('        for (int i = 0; i < Ni; i++) {\n')
        f.write('            FR1(ix,iy,i) = F_G(ix,iy,i);\n')
        f.write('            HR1(ix,iy,i) = H_G(ix,iy,i);\n')
        f.write('        }\n')
        f.write('    }\n')
        f.write('    else {\n')
        f.write('        for (int i = 0; i < Ni; i++) {\n')
        f.write('            double f1_, edotu;\n')
        f.write('            // temp variables\n')
        f.write('            f1_ = (F_G(ix,iy,i) + (dt/(2*tauf))*feq[i])/(1.0 + dt/(2*tauf));    //calc to temp variable first, for use later\n\n')
        f.write('            FR1(ix,iy,i) = f1_;        // save to global\n\n')
        f.write('            // temp variables\n')
        f.write('            edotu = ex[i]*ux + ey[i]*uy;\n\n')
        f.write('            HR1(ix,iy,i) = (H_G(ix,iy,i) - (dt/2.0)*edotu*((feq[i] - f1_)/tauhf) + (dt/(2.0*tauh))*heq[i])/(1.0 + dt/(2.0*tauh));\n')
        f.write('        }\n')
        f.write('    }\n')
        f.write('}\n')
        
        f.write('////////////////////////////////////////////////////////////////////////////////\n')
        f.write('//KERNEL: RK3_STEP2\n')
        f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
        
        f.write('// macros for RK3\n')
        f.write('#define FR2(x,y,i) fr2[x*Ny*Ni + y*Ni + i]\n')
        f.write('#define HR2(x,y,i) hr2[x*Ny*Ni + y*Ni + i]\n')
        
        f.write('__kernel void\n')
        f.write('RK3_STEP2(__global double* f_G,\n')
        f.write('    __global double* fr1,\n')
        f.write('    __global double* fr2,\n')
        f.write('    __global double* h_G,\n')
        f.write('    __global double* hr1,\n')
        f.write('    __global double* hr2,\n')
        f.write('    __global int* cell,\n')
        f.write('    __global int* bnd,\n')
        f.write('    __global double* therm,\n')
        f.write('    __global double* velX,\n')
        f.write('    __global double* velY,\n')
        f.write('    __global double* rho_G,\n')
        f.write('    __global double* ux_G,\n')
        f.write('    __global double* uy_G,\n')
        f.write('    __global double* T_G)\n')
        f.write('{\n')
        f.write('    //perform RK3 stepping\n\n')
        f.write('    // NOTE: as all equilibrium df are calulated from the same data, feq1 = feq2 etc, this allows for simplification of equations\n\n')
        f.write('    // global index\n')
        f.write('    size_t ix = get_global_id(0);\n')
        f.write('    size_t iy = get_global_id(1);\n\n')
        f.write('    // macroscopic properties\n')
        f.write('    double rho = RHO_G(ix,iy);\n')
        f.write('    double ux = UX_G(ix,iy);\n')
        f.write('    double uy = UY_G(ix,iy);\n')
        f.write('    double T = T_G(ix,iy);\n\n')
        f.write('    // calculate relaxation times from macroscopic properties\n')
        f.write('    double mu_ = mu*powr(T/T_ref,3.0/2.0)*((T_ref+S_v)/(T + S_v));\n')
        f.write('    double tauf = mu_/(rho*R*T);\n')
        f.write('    double tauh = tauf/Pr;\n')
        f.write('    double tauhf = (tauh*tauf)/(tauf - tauh);\n\n')
        f.write('    double feq[Ni];\n')
        f.write('    double heq[Ni];\n\n')
        f.write('    clEq2D(rho, ux, uy, T, feq, heq);\n\n')
        f.write('    int id = BND(ix,iy);\n')
        f.write('    int type = CELL(id);\n\n')
        f.write('    // --- RK STEP TWO----\n')
        f.write('    // calculate the first stage updated distribution functions \n\n')
        f.write('    if (type > 0) {\n')
        f.write('        for (int i = 0; i < Ni; i++) {\n')
        f.write('            FR2(ix,iy,i) = F_G(ix,iy,i);\n')
        f.write('            HR2(ix,iy,i) = H_G(ix,iy,i);\n')
        f.write('        }\n')
        f.write('    }\n')
        f.write('    else {\n\n')
        f.write('        double f1_, f2_, edotu;\n\n')
        f.write('        for (int i = 0; i < Ni; i++) {\n')
        f.write('            // temp variables\n')
        f.write('            f1_ = FR1(ix,iy,i);\n')
        f.write('            f2_ = (F_G(ix,iy,i) + (dt/(2*tauf))*f1_)/(1.0 + dt/(2*tauf));    //calc to temp variable first, for use later\n')
        f.write('\n')
        f.write('            FR2(ix,iy,i) = f2_;        // save to global\n')
        f.write('\n')
        f.write('            // temp variables\n')
        f.write('            edotu = ex[i]*ux + ey[i]*uy;\n')
        f.write('\n')
        f.write('            HR2(ix,iy,i) = (H_G(ix,iy,i) - (dt/2.0)*(edotu/tauhf)*(f1_ - f2_) + (dt/2.0)*(HR1(ix,iy,i)/tauh))/(1.0 + dt/(2.0*tauh));\n')
        f.write('        }\n')
        f.write('    }\n')
        f.write('}\n')
        
        f.write('////////////////////////////////////////////////////////////////////////////////\n')
        f.write('//KERNEL: RK3_STEP3\n')
        f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
        
        f.write('// macros for RK3\n')
        f.write('#define FR3(x,y,i) fr3[x*Ny*Ni + y*Ni + i]\n')
        f.write('#define HR3(x,y,i) hr3[x*Ny*Ni + y*Ni + i]\n')
        
        f.write('__kernel void\n')
        f.write('RK3_STEP3(__global double* f_G,\n')
        f.write('    __global double* fr2,\n')
        f.write('    __global double* fr3,\n')
        f.write('    __global double* h_G,\n')
        f.write('    __global double* hr2,\n')
        f.write('    __global double* hr3,\n')
        f.write('    __global int* cell,\n')
        f.write('    __global int* bnd,\n')
        f.write('    __global double* therm,\n')
        f.write('    __global double* velX,\n')
        f.write('    __global double* velY,\n')
        f.write('    __global double* rho_G,\n')
        f.write('    __global double* rho_3,\n')
        f.write('    __global double* ux_G,\n')
        f.write('    __global double* ux_3,\n')
        f.write('    __global double* uy_G,\n')
        f.write('    __global double* uy_3,\n')
        f.write('    __global double* T_G,\n')
        f.write('    __global double* T_3,\n')
        f.write('    __global double* fr2_flux_x,\n')
        f.write('    __global double* fr2_flux_y,\n')
        f.write('    __global double* hr2_flux_x,\n')
        f.write('    __global double* hr2_flux_y)\n')
        f.write('{\n')
        f.write('    //perform RK3 stepping\n\n')
        f.write('    size_t ix = get_global_id(0);\n')
        f.write('    size_t iy = get_global_id(1);\n\n')
        
        f.write('    // macroscopic properties\n')
        f.write('    double rho2 = RHO_G(ix,iy);\n')
        f.write('    double ux2 = UX_G(ix,iy);\n')
        f.write('    double uy2 = UY_G(ix,iy);\n')
        f.write('    double T2 = T_G(ix,iy);\n\n')
        
        f.write('    clMacroProp3(f_G, h_G, rho_3, ux_3, uy_3, T_3, fr2_flux_x, fr2_flux_y, hr2_flux_x, hr2_flux_y);\n\n')
        
        f.write('    double rho3 = RHO_3(ix,iy);\n')
        f.write('    double ux3 =  UX_3(ix,iy);\n')
        f.write('    double uy3 =  UY_3(ix,iy);\n')
        f.write('    double T3 =   T_3(ix,iy);\n\n')
        
        f.write('    // calculate relaxation times from macroscopic properties\n')
        f.write('    double mu_ = mu*powr(T2/T_ref,3.0/2.0)*((T_ref+S_v)/(T2 + S_v));\n')
        f.write('    double tauf2 = mu_/(rho2*R*T2);\n')
        f.write('    double tauh2 = tauf2/Pr;\n')
        f.write('    double tauhf2 = (tauh2*tauf2)/(tauf2 - tauh2);\n\n')
        
        f.write('    mu_ = mu*powr(T3/T_ref,3.0/2.0)*((T_ref+S_v)/(T3 + S_v));\n')
        f.write('    double tauf3 = mu_/(rho3*R*T3);\n')
        f.write('    double tauh3 = tauf3/Pr;\n')
        f.write('    double tauhf3 = (tauh3*tauf3)/(tauf3 - tauh3);\n')
        
        f.write('    double feq2[Ni];\n')
        f.write('    double heq2[Ni];\n\n')
        
        f.write('    double feq3[13];\n')
        f.write('    double heq3[13];\n\n')
        
        f.write('    clEq2D(rho2, ux2, uy2, T2, feq2, heq2);\n')
        f.write('    clEq2D(rho3, ux3, uy3, T3, feq3, heq3);\n\n')
        
        f.write('    int id = BND(ix,iy);\n')
        f.write('    int type = CELL(id);\n\n')
        
        f.write('    double flux_f2, flux_h2, edotu2, edotu3, f2_, f3_;\n\n')
        
        
        f.write('        // calculate the updated distribution functions\n')
        f.write('    if (type > 0) {\n')
        f.write('        for (int i = 0; i < Ni; i++) {\n')
        f.write('            FR3(ix,iy,i) = F_G(ix,iy,i);\n')
        f.write('            HR3(ix,iy,i) = H_G(ix,iy,i);\n')
        f.write('        }\n')
        f.write('    }\n')
        f.write('    else {\n')
        f.write('        for (int i = 0; i < Ni; i++) {\n')
        f.write('            flux_f2 = clCombineFLUX(fr2_flux_x, fr2_flux_y, i);\n\n')
        f.write('            f2_ = FR2(ix,iy,i);\n\n')
        f.write('            f3_ = (F_G(ix,iy,i) - flux_f2 + (dt/(2*tauf2))*(feq2[i] - f2_) + (dt/(2.0*tauf3))*feq3[i])/(1 + dt/(2*tauf3));\n\n')
        f.write('            FR3(ix,iy,i) = f3_;\n\n')
        f.write('            flux_h2 = clCombineFLUX(hr2_flux_x, hr2_flux_y, i);\n\n')
        f.write('            edotu2 = ex[i]*ux2 + ey[i]*uy2;\n')
        f.write('            edotu3 = ex[i]*ux3 + ey[i]*uy3;\n\n')
        f.write('            HR3(ix,iy,i) = (H_G(ix,iy,i) - flux_h2 - (dt/2.0)*(edotu2*((feq2[i] - f2_)/tauhf2) + edotu3*((feq3[i] - f3_)/tauhf3)) + \n')
        f.write('                (dt/2.0)*((heq2[i] - HR2(ix,iy,i))/tauh2) + (dt/2.0)*(heq3[i]/tauh3))/(1.0 + dt/(2.0*tauh3));\n')
        f.write('        }\n')
        f.write('    }\n')
        f.write('}\n\n')
        
        f.write('////////////////////////////////////////////////////////////////////////////////\n')
        f.write('//KERNEL: RK3_COMBINE\n')
        f.write('////////////////////////////////////////////////////////////////////////////////\n\n')
        
        f.write('__kernel void\n')
        f.write('RK3_COMBINE(__global double* f_G,\n')
        f.write('    __global double* fr2,\n')
        f.write('    __global double* fr3,\n')
        f.write('    __global double* h_G,\n')
        f.write('    __global double* hr2,\n')
        f.write('    __global double* hr3,\n')
        f.write('    __global int* cell,\n')
        f.write('    __global int* bnd,\n')
        f.write('    __global double* therm,\n')
        f.write('    __global double* velX,\n')
        f.write('    __global double* velY,\n')
        f.write('    __global double* rho_G,\n')
        f.write('    __global double* rho_3,\n')
        f.write('    __global double* ux_G,\n')
        f.write('    __global double* ux_3,\n')
        f.write('    __global double* uy_G,\n')
        f.write('    __global double* uy_3,\n')
        f.write('    __global double* T_G,\n')
        f.write('    __global double* T_3,\n')
        f.write('    __global double* fr2_flux_x,\n')
        f.write('    __global double* fr3_flux_x,\n')
        f.write('    __global double* fr2_flux_y,\n')
        f.write('    __global double* fr3_flux_y,\n')
        f.write('    __global double* hr2_flux_x,\n')
        f.write('    __global double* hr3_flux_x,\n')
        f.write('    __global double* hr2_flux_y,\n')
        f.write('    __global double* hr3_flux_y)\n')
        f.write('{\n')
        f.write('    //perform RK3 combination step\n\n')
        f.write('    size_t ix = get_global_id(0);\n')
        f.write('    size_t iy = get_global_id(1);\n\n')
        
        f.write('    // macroscopic properties\n')
        f.write('    double rho2 = RHO_G(ix,iy);\n')
        f.write('    double ux2 = UX_G(ix,iy);\n')
        f.write('    double uy2 = UY_G(ix,iy);\n')
        f.write('    double T2 = T_G(ix,iy);\n\n')
        
        f.write('    double rho3 = RHO_3(ix,iy);\n')
        f.write('    double ux3 =  UX_3(ix,iy);\n')
        f.write('    double uy3 =  UY_3(ix,iy);\n')
        f.write('    double T3 =   T_3(ix,iy);\n\n')
        
        f.write('    // calculate relaxation times from macroscopic properties\n')
        f.write('    double mu_ = mu*powr(T2/T_ref,3.0/2.0)*((T_ref+S_v)/(T2 + S_v));\n')
        f.write('    double tauf2 = mu_/(rho2*R*T2);\n')
        f.write('    double tauh2 = tauf2/Pr;\n')
        f.write('    double tauhf2 = (tauh2*tauf2)/(tauf2 - tauh2);\n\n')
        
        f.write('    mu_ = mu*powr(T3/T_ref,3.0/2.0)*((T_ref+S_v)/(T3 + S_v));\n')
        f.write('    double tauf3 = mu_/(rho3*R*T3);\n')
        f.write('    double tauh3 = tauf3/Pr;\n')
        f.write('    double tauhf3 = (tauh3*tauf3)/(tauf3 - tauh3);\n')
        
        f.write('    double feq2[Ni];\n')
        f.write('    double heq2[Ni];\n\n')
        
        f.write('    double feq3[13];\n')
        f.write('    double heq3[13];\n\n')
        
        f.write('    clEq2D(rho2, ux2, uy2, T2, feq2, heq2);\n')
        f.write('    clEq2D(rho3, ux3, uy3, T3, feq3, heq3);\n\n')
        
        f.write('    int id = BND(ix,iy);\n')
        f.write('    int type = CELL(id);\n\n')
        
        f.write('    double flux_f2, flux_h2, flux_f3, flux_h3, edotu2, edotu3;\n')
        f.write('    double f2_, f3_, h2_, h3_;\n\n')
        
        
        f.write('        // --- RK COMBINATION ----\n')
        f.write('        // calculate the updated distribution functions\n')
        f.write('    if (type == 0) {\n')
        f.write('        for (int i = 0; i < Ni; i++) {\n')
        f.write('            f2_ = FR2(ix,iy,i);\n')
        f.write('            f3_ = FR3(ix,iy,i);\n\n')
    
        f.write('            flux_f2 = clCombineFLUX(fr2_flux_x, fr2_flux_y, i);\n')
        f.write('            flux_f3 = clCombineFLUX(fr3_flux_x, fr3_flux_y, i);\n\n')
    
        f.write('            F_G(ix,iy,i) = F_G(ix,iy,i) - (1.0/2.0)*(flux_f2 + flux_f3) + (dt/2.0)*((feq2[i] - f2_)/tauf2 + (feq3[i] - f3_)/tauf3);\n\n')
        
        f.write('            h2_ = HR2(ix,iy,i);\n')
        f.write('            h3_ = HR3(ix,iy,i);\n\n')
        
        f.write('            flux_h2 = clCombineFLUX(hr2_flux_x, hr2_flux_y, i);\n')
        f.write('            flux_h3 = clCombineFLUX(hr3_flux_x, hr3_flux_y, i);\n\n')
        
        f.write('            edotu2 = ex[i]*ux2 + ey[i]*uy2;\n')
        f.write('            edotu3 = ex[i]*ux3 + ey[i]*uy3;\n\n')
        
        f.write('            H_G(ix,iy,i) = H_G(ix,iy,i) - 0.5*(flux_h2 + flux_h3) + (dt/2.0)*((heq2[i] - h2_)/tauh2 + (heq3[i] - h3_)/tauh3) \n')
        f.write('                - (dt/2.0)*((edotu2/tauhf2)*(feq2[i] - f2_) + (edotu3/tauhf3)*(feq3[i] - f3_));\n')
        f.write('        }\n')
        f.write('    }\n')
        f.write('    // update macro properties\n')
        f.write('    clMacroProp(f_G, h_G, rho_G, ux_G, uy_G, T_G);\n')
        f.write('}\n')
            
    f.flush()
    f.close()
    
    return fileName