f.write('#include "LBM_2D_NS_cuKernel.h"\n')
f.write('\n')
f.write('__constant__ unsigned int mirrorNS[13] = {0,1,4,3,2,8,7,6,5,9,12,11,10};\n')
f.write('__constant__ unsigned int mirrorEW[13] = {0,3,2,1,4,6,5,8,7,11,10,9,12};\n')
f.write('\n')
f.write('__constant__ int xx[4] = {-1,1,0,0};\n')
f.write('__constant__ int yy[4] = {0,0,-1,1};\n')
f.write('__constant__ unsigned	int ii[4][4] = {{1,5,8,9},{3,6,7,11},{2,5,6,10},{4,7,8,12}};\n')
f.write('__constant__ unsigned	int inv[4][4] = {{3,6,7,11},{1,5,8,9},{4,7,8,12},{2,5,6,10}};\n')
f.write('\n')
f.write('__device__ int errEq = 0;\n')
f.write('\n')
f.write('////////////////////////////////////////////////////////////////////////////////\n')
f.write('// INLINE\n')
f.write('////////////////////////////////////////////////////////////////////////////////\n')
f.write('\n')
f.write('// equilibrium functions for f\n')
f.write('\n')
f.write('__device__ inline double f0(double rho, double u, double v, double T)\n')
f.write('{\n')
f.write('	//rest particle equilibrium function\n')
f.write('	return (rho/4.0)*(4 + 10*pow(T,2) + pow(u,4) - 5*pow(v,2) + pow(v,4) + 10*T*(-1 + pow(u,2) + pow(v,2)) + pow(u,2)*(-5 + 4*pow(v,2)));\n')
f.write('}\n')
f.write('\n')
f.write('__device__ inline double f1(double rho, double u, double v, double T)\n')
f.write('{\n')
f.write('	return (rho/6.0)*(-6*pow(T,2) - u*(1 + u)*(-4 + pow(u,2) + 3*pow(v,2)) - T*(-4 + 6*u + 9*pow(u,2) + 3*pow(v,2)));\n')
f.write('}\n')
f.write('\n')
f.write('__device__ inline double f5(double rho, double u, double v, double T)\n')
f.write('{\n')
f.write('	return (rho/4.0)*((T + u + pow(u,2))*(T + v + pow(v,2)));\n')
f.write('}\n')
f.write('\n')
f.write('__device__ inline double f9(double rho, double u, double v, double T)\n')
f.write('{\n')
f.write('	return (rho/24.0)*(3*pow(T,2) + (-1 + u)*u*(1 + u)*(2 + u) + T*(-1 + 6*u*(1 + u)));\n')
f.write('}\n')
f.write('\n')
f.write('// equilibrium functions for h\n')
f.write('\n')
f.write('__device__ inline double h0(double K, double T, double u, double v)\n')
f.write('{\n')
f.write('return (10*(16 + 3*K)*pow(T,3) + 3*T*(8 + 4*K - 40*pow(u,2) - 5*K*pow(u,2) + 20*pow(u,4) \n')
f.write('	+ K*pow(u,4) + (-5*(8 + K) + 4*(15 + K)*pow(u,2))*pow(v,2) + (20 + K)*pow(v,4)) \n')
f.write('	+ 30*pow(T,2)*(-4 + 9*pow(u,2) + 9*pow(v,2) + K*(-1 + pow(u,2) + pow(v,2))) \n')
f.write('	+ 3*(pow(u,2) + pow(v,2))*(4 + pow(u,4) - 5*pow(v,2) + pow(v,4) + pow(u,2)*(-5 + 4*pow(v,2))))/24.0;\n')
f.write('}\n')
f.write('\n')
f.write('__device__ inline double h1(double K, double T, double u, double v)\n')
f.write('{\n')
f.write('	return (-2*(16 + 3*K)*pow(T,3) - u*(1 + u)*(pow(u,2) + pow(v,2))*(-4 + pow(u,2) + 3*pow(v,2))\n')
f.write('		- T*(u*(-4*(4 + K) - 4*(7 + K)*u + (14 + K)*pow(u,2) + (19 + K)*pow(u,3)) + (-4 + 3*u*(10\n')
f.write('		+ K + (14 + K)*u))*pow(v,2) + 3*pow(v,4)) - pow(T,2)*(-16 + 6*u*(6 + 13*u) + 30*pow(v,2)\n')
f.write('		+ K*(-4 + 6*u + 9*pow(u,2) + 3*pow(v,2))))/12.0;\n')
f.write('}\n')
f.write('\n')
f.write('__device__ inline double h5(double K, double T, double u, double v)\n')
f.write('{\n')
f.write('	return ((16 + 3*K)*pow(T,3) + 3*u*(1 + u)*v*(1 + v)*(pow(u,2) + pow(v,2)) + 3*pow(T,2)*((6 + K)*u \n')
f.write('		+ (9 + K)*pow(u,2) + v*(6 + K + (9 + K)*v)) + 3*T*(pow(u,3) + pow(u,4) + pow(v,3)*(1 + v)\n')
f.write('		+ u*v*(6 + K + (9 + K)*v) + pow(u,2)*v*(9 + K + (12 + K)*v)))/24.0;\n')
f.write('}\n')
f.write('\n')
f.write('__device__ inline double h9(double K, double T, double u, double v)\n')
f.write('{\n')
f.write('	return ((16 + 3*K)*pow(T,3) + T*u*(-8 + K*(-1 + u)*(1 + u)*(2 + u) + u*(-7 + 2*u*(11 + 8*u))) \n')
f.write('		+ T*(-1 + 6*u*(1 + u))*pow(v,2) + (-1 + u)*u*(1 + u)*(2 + u)*(pow(u,2) + pow(v,2)) \n')
f.write('		+ pow(T,2)*(-4 + 36*u + 51*pow(u,2) + K*(-1 + 6*u*(1 + u)) + 3*pow(v,2)))/48.0;\n')
f.write('}\n')
f.write('\n')
f.write('////////////////////////////////////////////////////////////////////////////////\n')
f.write('// Functions\n')
f.write('////////////////////////////////////////////////////////////////////////////////\n')
f.write('\n')
f.write('__device__ void\n')
f.write('cuEq2D(double rho, double u_, double v_, double T_, double Tc, double R, double K, double* eqf, double* eqh)\n')
f.write('{\n')
f.write('	//returns the equilibrium values for each velocity vector given the current\n')
f.write('	// macroscopic values and the corresponding reference quantities\n')
f.write('	\n')
f.write('	double sRTc = sqrt(R*Tc);\n')
f.write('	double u = u_/sRTc;\n')
f.write('	double v = v_/sRTc;\n')
f.write('	double T = T_/Tc;\n')
f.write('\n')
f.write('	eqf[0] = f0(rho,u,v,T);\n')
f.write('	eqf[1] = f1(rho,u,v,T);\n')
f.write('	eqf[2] = f1(rho,v,u,T);\n')
f.write('	eqf[3] = f1(rho,-u,v,T);\n')
f.write('	eqf[4] = f1(rho,-v,u,T);\n')
f.write('	eqf[5] = f5(rho,u,v,T);\n')
f.write('	eqf[6] = f5(rho,-u,v,T);\n')
f.write('	eqf[7] = f5(rho,-u,-v,T);\n')
f.write('	eqf[8] = f5(rho,u,-v,T);\n')
f.write('	eqf[9] = f9(rho,u,v,T);\n')
f.write('	eqf[10] = f9(rho,v,u,T);\n')
f.write('	eqf[11] = f9(rho,-u,v,T);\n')
f.write('	eqf[12] = f9(rho,-v,u,T);\n')
f.write('\n')
f.write('	double rRTc = rho*R*Tc;\n')
f.write('\n')
f.write('	eqh[0] = rRTc*h0(K,T,u,v);\n')
f.write('	eqh[1] = rRTc*h1(K,T,u,v);\n')
f.write('	eqh[2] = rRTc*h1(K,T,v,u);\n')
f.write('	eqh[3] = rRTc*h1(K,T,-u,v);\n')
f.write('	eqh[4] = rRTc*h1(K,T,-v,u);\n')
f.write('	eqh[5] = rRTc*h5(K,T,u,v);\n')
f.write('	eqh[6] = rRTc*h5(K,T,-u,v);\n')
f.write('	eqh[7] = rRTc*h5(K,T,-u,-v);\n')
f.write('	eqh[8] = rRTc*h5(K,T,u,-v);\n')
f.write('	eqh[9] = rRTc*h9(K,T,u,v);\n')
f.write('	eqh[10] =rRTc*h9(K,T,v,u);\n')
f.write('	eqh[11] =rRTc*h9(K,T,-u,v);\n')
f.write('	eqh[12] =rRTc*h9(K,T,-v,u);\n')
f.write('\n')
f.write('	//check\n')
f.write('	double sum_f = 0;\n')
f.write('	double sum_h = 0;\n')
f.write('	for (int i = 0; i < 13; i++)\n')
f.write('	{\n')
f.write('		sum_f += eqf[i];\n')
f.write('		sum_h += eqh[i];\n')
f.write('	}\n')
f.write('	double U = sqrt(u_*u_ + v_*v_);\n')
f.write('	double E = (U*U + (K+2.0)*R*T_)/2.0;\n')
f.write('\n')
f.write('	double diff1 = sum_h/rho - E;\n')
f.write('	double diff2 = sum_f - rho;\n')
f.write('\n')
f.write('	if (diff1 > 1 || diff2 > 1)\n')
f.write('	{\n')
f.write('		errEq = 1;\n')
f.write('	}\n')
f.write('}\n')
f.write('\n')
f.write('__device__ int\n')
f.write('cuSign(double a)\n')
f.write('{\n')
f.write('	//returns: a = 0 -> 0, a = neg -> -1, a = pos -> 1\n')
f.write('	if (a > 0)\n')
f.write('	{\n')
f.write('		return 1;\n')
f.write('	}\n')
f.write('	else if (a < 0)\n')
f.write('	{\n')
f.write('		return -1;\n')
f.write('	}\n')
f.write('	else\n')
f.write('	{\n')
f.write('		return 0;\n')
f.write('	}\n')
f.write('}\n')
f.write('\n')
f.write('__device__ void\n')
f.write('cuMirIndex(int i, int mir_x, int mir_y, int& i_x, int& i_y)\n')
f.write('{\n')
f.write('	// gives the mirrored index about the axes defined by inputs mir_x, and mir_y\n')
f.write('\n')
f.write('	// initialise with no mirror\n')
f.write('	i_x = i;\n')
f.write('	i_y = i;\n')
f.write('\n')
f.write('	// mirror about x\n')
f.write('	if (mir_x == 1)	\n')
f.write('	{\n')
f.write('		i_x = mirrorNS[i];\n')
f.write('	}\n')
f.write('	\n')
f.write('	// mirror about y\n')
f.write('	if(mir_y == 1)\n')
f.write('	{\n')
f.write('		i_y = mirrorEW[i];\n')
f.write('	}\n')
f.write('\n')
f.write('}\n')
f.write('\n')
f.write('__device__\n')
f.write('int cuIndex(int i, int pm, int d, simData* sim, int& mir)\n')
f.write('{\n')
f.write('	int Ny = (*sim).Ny;\n')
f.write('	int Nx = (*sim).Nx;\n')
f.write('\n')
f.write('	// d = 0 -> x\n')
f.write('	// d = 1 -> y\n')
f.write('	i = i + pm;\n')
f.write('	mir = 0;\n')
f.write('\n')
f.write('	if (d == 0)\n')
f.write('	{\n')
f.write('		if (i < 0)\n')
f.write('		{\n')
f.write('			if ((*sim).periodicX > 0)\n')
f.write('			{\n')
f.write('				i = Nx + i;\n')
f.write('			}\n')
f.write('			else if ((*sim).mirrorW > 0)\n')
f.write('			{\n')
f.write('				i = -i - 1;\n')
f.write('				mir = 1;\n')
f.write('			}\n')
f.write('			else\n')
f.write('			{\n')
f.write('				i = 0; //zeroth order extrapolation\n')
f.write('			}\n')
f.write('		}\n')
f.write('		else if (i > Nx - 1)\n')
f.write('		{\n')
f.write('			if ((*sim).periodicX > 0)\n')
f.write('			{\n')
f.write('				i = i - Nx;\n')
f.write('			}\n')
f.write('			else if ((*sim).mirrorE > 0)\n')
f.write('			{\n')
f.write('				i = 2*Nx - i - 1;\n')
f.write('				mir = 1;\n')
f.write('			}\n')
f.write('			else\n')
f.write('			{\n')
f.write('				i = Nx - 1; //zeroth order extrapolation\n')
f.write('			}\n')
f.write('		}\n')
f.write('	}\n')
f.write('\n')
f.write('	else if (d == 1)\n')
f.write('	{\n')
f.write('		if (i < 0)\n')
f.write('		{\n')
f.write('			if ((*sim).periodicY > 0)\n')
f.write('			{\n')
f.write('				i = Ny + i;\n')
f.write('			}\n')
f.write('			else if ((*sim).mirrorS > 0)\n')
f.write('			{\n')
f.write('				i = -i - 1;\n')
f.write('				mir = 1;\n')
f.write('			}\n')
f.write('			else\n')
f.write('			{\n')
f.write('				i = 0; //zeroth order extrapolation\n')
f.write('			}\n')
f.write('		}\n')
f.write('		else if (i > Ny - 1)\n')
f.write('		{\n')
f.write('			if ((*sim).periodicY > 0)\n')
f.write('			{\n')
f.write('				i = i - Ny;\n')
f.write('			}\n')
f.write('			else if ((*sim).mirrorN > 0)\n')
f.write('			{\n')
f.write('				i = 2*Ny - i - 1;\n')
f.write('				mir = 1;\n')
f.write('			}\n')
f.write('			else\n')
f.write('			{\n')
f.write('				i = Ny - 1; //zeroth order extrapolation\n')
f.write('			}\n')
f.write('		}\n')
f.write('	}\n')
f.write('\n')
f.write('	return i;\n')
f.write('}\n')
f.write('\n')
f.write('__device__ void\n')
f.write('cuStencil(double* f_d, double* Sx, double* Sy, int n, int i, simData* sim, int* solid_d)\n')
f.write('{\n')
f.write('	// create a stencil of given length for the Flux method specified\n')
f.write('\n')
f.write('	if (i == 0)\n')
f.write('	{\n')
f.write('		return;\n')
f.write('	}\n')
f.write('\n')
f.write('	int Ny = (*sim).Ny;\n')
f.write('\n')
f.write('	// thread index\n')
f.write('	int tx = threadIdx.x;\n')
f.write('	int ty = threadIdx.y;\n')
f.write('\n')
f.write('	//global index\n')
f.write('	int ix = blockIdx.x*blockDim.x + tx;\n')
f.write('	int iy = blockIdx.y*blockDim.y + ty;\n')
f.write('\n')
f.write('	// velocity vector, in integer values for indexing\n')
f.write('	int ex = cuSign((*sim).e[i].x);\n')
f.write('	int ey = cuSign((*sim).e[i].y);\n')
f.write('\n')
f.write('	int low = (n - 1) / 2;	// max/min num of stencil from centre\n')
f.write('\n')
f.write('	// calculate stencil along x and y\n')
f.write('	int jx1 = ix - ex*low;	//start of stencil index\n')
f.write('	int jy1 = iy - ey*low;\n')
f.write('\n')
f.write('	int jx, jy;\n')
f.write('	int mir_x, mir_y;\n')
f.write('	int i_x, i_y;\n')
f.write('\n')
f.write('	int sld_x = 0;\n')
f.write('	int sld_y = 0;\n')
f.write('	int sldx[5];\n')
f.write('	int sldy[5];\n')
f.write('\n')
f.write('	int sld;\n')
f.write('\n')
f.write('	for (int j = 0; j < n; j++)	// put together stencil along axis lines, start on low side, go to hi side: [j-low <-> j+low]\n')
f.write('	{\n')
f.write('		jx = cuIndex(jx1,ex*j,0,sim,mir_y);\n')
f.write('		jy = cuIndex(jy1,ey*j,1,sim,mir_x);\n')
f.write('\n')
f.write('		cuMirIndex(i,mir_x,mir_y,i_x,i_y);	// mirror indexes if required\n')
f.write('\n')
f.write('		sld = GSLD(ix,iy);\n')
f.write('\n')
f.write('		// x\n')
f.write('		Sx[j] = GF(jx,iy,i_y);\n')
f.write('\n')
f.write('		if (sld >= 0)\n')
f.write('		{\n')
f.write('			sldx[j] = 1;\n')
f.write('			sld_x = 1;\n')
f.write('		}\n')
f.write('		else\n')
f.write('		{\n')
f.write('			sldx[j] = 0;\n')
f.write('		}\n')
f.write('\n')
f.write('		// y\n')
f.write('		Sy[j] = GF(ix,jy,i_x);\n')
f.write('\n')
f.write('		if (sld >= 0)\n')
f.write('		{\n')
f.write('			sldy[j] = 1;\n')
f.write('			sld_y = 1;\n')
f.write('		}\n')
f.write('		else\n')
f.write('		{\n')
f.write('			sldy[j] = 0;\n')
f.write('		}\n')
f.write('	}\n')
f.write('\n')
f.write('	if (sld_x == 1)\n')
f.write('	{\n')
f.write('		int diff;	// difference between indexes of sldx\n')
f.write('		int x_;		// location of edge solid node, outside coords\n')
f.write('		int j_;		// location of edge solid node, stencil coords\n')
f.write('		\n')
f.write('		// find where edge solid node is\n')
f.write('		for (int j = 0; j < n - 1; j++)\n')
f.write('		{\n')
f.write('			diff = sldx[j] - sldx[j+1];\n')
f.write('			if (diff > 0)\n')
f.write('			{\n')
f.write('				j_ = j;\n')
f.write('				x_ = cuIndex(jx1,ex*j,0,sim,mir_y);\n')
f.write('				break;\n')
f.write('			}\n')
f.write('			else if (diff < 0)\n')
f.write('			{\n')
f.write('				j_ = j + 1;\n')
f.write('				x_ = cuIndex(jx1,ex*(j + 1),0,sim,mir_y);\n')
f.write('				break;\n')
f.write('			}\n')
f.write('		}\n')
f.write('\n')
f.write('		// update solid part of stencil with linear extrapolation of actual stencil\n')
f.write('\n')
f.write('		int xm1 = cuIndex(x_,ex*diff,0,sim,mir_y);		// closest fluid node\n')
f.write('		int xm2 = cuIndex(x_,ex*2*diff,0,sim,mir_y);		// next closest fluid node\n')
f.write('\n')
f.write('		Sx[j_] = 2*GF(xm1,iy,i) - GF(xm2,iy,i);\n')
f.write('\n')
f.write('		int j__ = j_ - diff;\n')
f.write('\n')
f.write('		if (j__ >= 0 && j__ < n) // update next one along if stencil is long enough\n')
f.write('		{\n')
f.write('			Sx[j__] = Sx[j_];\n')
f.write('		}\n')
f.write('	}\n')
f.write('\n')
f.write('	if (sld_y == 1)\n')
f.write('	{\n')
f.write('		int diff;	// difference between indexes of sldx\n')
f.write('		int y_;		// location of edge solid node, outside coords\n')
f.write('		int j_;		// location of edge solid node, stencil coords\n')
f.write('		\n')
f.write('		// find where edge solid node is\n')
f.write('		for (int j = 0; j < n - 1; j++)\n')
f.write('		{\n')
f.write('			diff = sldy[j] - sldy[j+1];\n')
f.write('			if (diff > 0)\n')
f.write('			{\n')
f.write('				j_ = j;\n')
f.write('				y_ = cuIndex(jy1,ey*j,1,sim,mir_x);\n')
f.write('				break;\n')
f.write('			}\n')
f.write('			else if (diff < 0)\n')
f.write('			{\n')
f.write('				j_ = j + 1;\n')
f.write('				y_ = cuIndex(jy1,ey*(j + 1),1,sim,mir_x);\n')
f.write('				break;\n')
f.write('			}\n')
f.write('		}\n')
f.write('\n')
f.write('		// update solid part of stencil with linear extrapolation of actual stencil\n')
f.write('\n')
f.write('		int ym1 = cuIndex(y_,ey*diff,0,sim,mir_x);		// closest fluid node\n')
f.write('		int ym2 = cuIndex(y_,ey*2*diff,0,sim,mir_x);		// next closest fluid node\n')
f.write('\n')
f.write('		Sy[j_] = 2*GF(ix,ym1,i) - GF(ix,ym2,i);\n')
f.write('\n')
f.write('		int j__ = j_ - diff;\n')
f.write('\n')
f.write('		if (j__ >= 0 && j__ < n)	// update next one along if stencil is long enough\n')
f.write('		{\n')
f.write('			Sy[j__] = Sy[j_];\n')
f.write('		}\n')
f.write('	}\n')
f.write('}\n')
f.write('\n')
f.write('__device__ double\n')
f.write('cuMinmod(double a, double b)\n')
f.write('{\n')
f.write('	// calculate minmod function\n')
f.write('\n')
f.write('	double out;\n')
f.write('\n')
f.write('	if ((abs(a) < abs(b)) && (a*b > 0))\n')
f.write('		out = a;\n')
f.write('	else if ((abs(b) < abs(a)) && (a*b > 0))\n')
f.write('		out = b;\n')
f.write('	else if (a == b)\n')
f.write('		out = a;\n')
f.write('	else if (a*b <= 0)\n')
f.write('		out = 0;\n')
f.write('	return out;\n')
f.write('}\n')
f.write('\n')
f.write('__device__ double\n')
f.write('cuNND(double* S, double e)\n')
f.write('{\n')
f.write('	// calculate the flux by the NND method (2nd order accurate, CFL_max = 2/3)\n')
f.write('\n')
f.write('	int n = 1;\n')
f.write('\n')
f.write('	double Fp_I, Fp_Ip1, Fp_Im1;\n')
f.write('\n')
f.write('	double vP = abs(e);\n')
f.write('\n')
f.write('	if (vP == 0)\n')
f.write('	{\n')
f.write('		return 0;\n')
f.write('	}\n')
f.write('\n')
f.write('	Fp_I   = vP*S[n];\n')
f.write('	Fp_Ip1 = vP*S[n+1];\n')
f.write('	Fp_Im1 = vP*S[n-1];\n')
f.write('\n')
f.write('	double dFp_Ip12, dFp_Im12;\n')
f.write('\n')
f.write('	dFp_Ip12 = Fp_Ip1 - Fp_I;\n')
f.write('	dFp_Im12 = Fp_I - Fp_Im1;\n')
f.write('\n')
f.write('	double F_Ip12;\n')
f.write('\n')
f.write('	F_Ip12 = Fp_I + 0.5*cuMinmod(dFp_Ip12,dFp_Im12);\n')
f.write('\n')
f.write('	return F_Ip12;\n')
f.write('}\n')
f.write('\n')
f.write('__device__ double\n')
f.write('cuWENO5(double* S, double e)\n')
f.write('{\n')
f.write('	// calculate the flux term of the WENO5 scheme for one flow direction\n')
f.write('\n')
f.write('	double epsilon = (double) 1e-6;\n')
f.write('	double posFlow = abs(e);\n')
f.write('	double F_Ip12;\n')
f.write('\n')
f.write('	if (posFlow == 0)\n')
f.write('	{\n')
f.write('		return 0;\n')
f.write('	}\n')
f.write('	else\n')
f.write('	{\n')
f.write('		double Sp[5];\n')
f.write('		for (int i = 0; i < 5; i++)\n')
f.write('		{\n')
f.write('			Sp[i] = S[i]*posFlow;\n')
f.write('		}\n')
f.write('\n')
f.write('		int n = 2;\n')
f.write('\n')
f.write('		double B0p, B1p, B2p, alpha0p, alpha1p, alpha2p;\n')
f.write('		double omega0p, omega1p, omega2p, f0p, f1p, f2p;\n')
f.write('\n')
f.write('		B0p = (13.0/12.0)*pow(Sp[n-2] - 2.0*Sp[n-1] + Sp[n],2) + (1.0/4.0)*pow(Sp[n-2] - 4.0*Sp[n-1] + 3.0*Sp[n],2);\n')
f.write('		B1p = (13.0/12.0)*pow(Sp[n-1] - 2.0*Sp[n] + Sp[n+1],2) + (1.0/4.0)*pow(Sp[n-1] - Sp[n+1],2);\n')
f.write('		B2p = (13.0/12.0)*pow(Sp[n] - 2.0*Sp[n+1] + Sp[n+2],2) + (1.0/4.0)*pow(3.0*Sp[n] - 4.0*Sp[n+1] + Sp[n+2],2);\n')
f.write('\n')
f.write('		alpha0p = (1.0/10.0)*pow(1.0/(epsilon + B0p),2);\n')
f.write('		alpha1p = (6.0/10.0)*pow(1.0/(epsilon + B1p),2);\n')
f.write('		alpha2p = (3.0/10.0)*pow(1.0/(epsilon + B2p),2);\n')
f.write('\n')
f.write('		omega0p = alpha0p/(alpha0p + alpha1p + alpha2p);\n')
f.write('		omega1p = alpha1p/(alpha0p + alpha1p + alpha2p);\n')
f.write('		omega2p = alpha2p/(alpha0p + alpha1p + alpha2p);\n')
f.write('\n')
f.write('		f0p = (2.0/6.0)*Sp[n-2] - (7.0/6.0)*Sp[n-1] + (11.0/6.0)*Sp[n];\n')
f.write('		f1p = -(1.0/6.0)*Sp[n-1] + (5.0/6.0)*Sp[n] + (2.0/6.0)*Sp[n+1];\n')
f.write('		f2p = (2.0/6.0)*Sp[n] + (5.0/6.0)*Sp[n+1] - (1.0/6.0)*Sp[n+2];\n')
f.write('\n')
f.write('		F_Ip12 = omega0p*f0p + omega1p*f1p + omega2p*f2p;\n')
f.write('	}\n')
f.write('\n')
f.write('	return F_Ip12;\n')
f.write('}\n')
f.write('\n')
f.write('__device__ void\n')
f.write('cuFLUX(double* f, int i, simData* sim, int* solid_d, double2& flux)\n')
f.write('{\n')
f.write('	// choose flux method\n')
f.write('\n')
f.write('	double ex, ey;\n')
f.write('\n')
f.write('	ex = (*sim).e[i].x;\n')
f.write('	ey = (*sim).e[i].y;\n')
f.write('\n')
f.write('	if ((*sim).FMETHOD == 0)\n')
f.write('	{\n')
f.write('		//NND\n')
f.write('		double Sx[3];\n')
f.write('		double Sy[3];\n')
f.write('\n')
f.write('		cuStencil(f, Sx, Sy, 3, i, sim, solid_d);\n')
f.write('\n')
f.write('		flux.x = cuNND(Sx,ex);\n')
f.write('		flux.y = cuNND(Sy,ey);\n')
f.write('	}\n')
f.write('	else if ((*sim).FMETHOD == 1)\n')
f.write('	{\n')
f.write('		// WENO5\n')
f.write('		double Sx[5];\n')
f.write('		double Sy[5];\n')
f.write('\n')
f.write('		cuStencil(f, Sx, Sy, 5, i, sim, solid_d);\n')
f.write('\n')
f.write('		flux.x = cuWENO5(Sx, ex);\n')
f.write('		flux.y = cuWENO5(Sy, ey);\n')
f.write('	}\n')
f.write('}\n')
f.write('\n')
f.write('__device__ double\n')
f.write('cuCombineFLUX(double2* fluxOut, int i, simData* sim)\n')
f.write('{\n')
f.write('	// calculates the combined flux given all the fluxes out of each node\n')
f.write('\n')
f.write('	int Ny = (*sim).Ny;\n')
f.write('\n')
f.write('	// thread index\n')
f.write('	int tx = threadIdx.x;\n')
f.write('	int ty = threadIdx.y;\n')
f.write('\n')
f.write('	//global index\n')
f.write('	int ix = blockIdx.x*blockDim.x + tx;\n')
f.write('	int iy = blockIdx.y*blockDim.y + ty;\n')
f.write('\n')
f.write('	// velocity vector, in integer values for indexing\n')
f.write('	int ex = cuSign((*sim).e[i].x);\n')
f.write('	int ey = cuSign((*sim).e[i].y);\n')
f.write('\n')
f.write('	int mir_x, mir_y;\n')
f.write('\n')
f.write('	int x_ = cuIndex(ix,-ex,0,sim,mir_y);\n')
f.write('	int y_ = cuIndex(iy,-ey,1,sim,mir_x);\n')
f.write('\n')
f.write('	if (i == 0)\n')
f.write('	{\n')
f.write('		return 0;\n')
f.write('	}\n')
f.write('	else\n')
f.write('	{\n')
f.write('		double dt = (*sim).dt;\n')
f.write('		double dx = (*sim).dx;\n')
f.write('		double dy = (*sim).dy;\n')
f.write('\n')
f.write('		int i_x, i_y;\n')
f.write('\n')
f.write('		cuMirIndex(i,mir_x,mir_y,i_x,i_y);	// mirror indexes if required\n')
f.write('\n')
f.write('\n')
f.write('		double flux_out = dt*(GFOUTx(ix,iy,i)/dx + GFOUTy(ix,iy,i)/dy);\n')
f.write('\n')
f.write('		double flux_in = dt*(GFOUTx(x_,iy,i_y)/dx + GFOUTy(ix,y_,i_x)/dy);\n')
f.write('\n')
f.write('		return flux_out - flux_in;\n')
f.write('	}\n')
f.write('}\n')
f.write('\n')
f.write('__device__ void\n')
f.write('cuPosFlux(double* f, double* h, int i, int* solid_d, simData* sim, double2* f_flux, double2* h_flux)\n')
f.write('{\n')
f.write('	// function to calculate all positive fluxes along axis (x & y) lines for fluid nodes\n')
f.write('	// store fluxes in global memory\n')
f.write('\n')
f.write('	// thread index\n')
f.write('	int tx = threadIdx.x;\n')
f.write('	int ty = threadIdx.y;\n')
f.write('\n')
f.write('	//global index\n')
f.write('	int ix = blockIdx.x*blockDim.x + tx;\n')
f.write('	int iy = blockIdx.y*blockDim.y + ty;\n')
f.write('\n')
f.write('	int Ny = (*sim).Ny;\n')
f.write('\n')
f.write('	// temporary flux storage\n')
f.write('\n')
f.write('	double2 flux_f, flux_h;\n')
f.write('\n')
f.write('	int sld = GSLD(ix,iy);\n')
f.write('\n')
f.write('	if (sld < 0)	// only perform fluxes on fluid and permanent nodes\n')
f.write('	{\n')
f.write('		cuFLUX(f,i,sim,solid_d,flux_f);\n')
f.write('		cuFLUX(h,i,sim,solid_d,flux_h);\n')
f.write('\n')
f.write('		// store fluxes in global memory\n')
f.write('		GFLUXFx(ix,iy,i) = flux_f.x;\n')
f.write('		GFLUXFy(ix,iy,i) = flux_f.y;\n')
f.write('\n')
f.write('		GFLUXHx(ix,iy,i) = flux_h.x;\n')
f.write('		GFLUXHy(ix,iy,i) = flux_h.y;\n')
f.write('	}\n')
f.write('}\n')
f.write('\n')
f.write('__global__ void\n')
f.write('MACRO_PROPERTIES(double* f_d, double* h_d, simData* sim, double* rho_d, double2* u_d, double* T_d, double* p_d)\n')
f.write('{\n')
f.write('\n')
f.write('	// Block index\n')
f.write('\n')
f.write('	//global index\n')
f.write('	int ix = blockIdx.x*blockDim.x + threadIdx.x;\n')
f.write('	int iy = blockIdx.y*blockDim.y + threadIdx.y;\n')
f.write('\n')
f.write('	int Ny = (*sim).Ny;\n')
f.write('\n')
f.write('	double rho, T, p, f;\n')
f.write('	double2 u;\n')
f.write('	double rho_ux, rho_uy, sum_h;\n')
f.write('\n')
f.write('	rho = 0;\n')
f.write('	rho_ux = 0;\n')
f.write('	rho_uy = 0;\n')
f.write('	sum_h = 0;\n')
f.write('\n')
f.write('	//#pragma unroll 13\n')
f.write('	for (int i = 0; i < 13; i++)\n')
f.write('	{\n')
f.write('		f = GF(ix,iy,i);\n')
f.write('\n')
f.write('		rho += f;\n')
f.write('		rho_ux += f*(*sim).e[i].x;\n')
f.write('		rho_uy += f*(*sim).e[i].y;\n')
f.write('		sum_h += GH(ix,iy,i);\n')
f.write('	}\n')
f.write('\n')
f.write('	u.x = rho_ux / rho;\n')
f.write('	u.y = rho_uy / rho;\n')
f.write('\n')
f.write('	double usq = sqrt(u.x*u.x + u.y*u.y);\n')
f.write('\n')
f.write('	usq = usq*usq;\n')
f.write('\n')
f.write('	T = 2.0*(sum_h/rho - usq/2.0)/((*sim).b*(*sim).R);\n')
f.write('\n')
f.write('	p = rho*(*sim).R*T;\n')
f.write('\n')
f.write('	// save macro-properties to device memory\n')
f.write('	GRHO(ix,iy) = rho;\n')
f.write('	GU(ix,iy) = u;\n')
f.write('	GT(ix,iy) = T;\n')
f.write('	GP(ix,iy) = p;\n')
f.write('}\n')
f.write('\n')
f.write('__global__ void\n')
f.write('	GLOBAL_FLUXES(double* f, double* h, simData* sim, int* solid, double2* fluxf, double2* fluxh)\n')
f.write('{\n')
f.write('	// calculate all outgoing fluxes for the given distribution functions and save to global memory.\n')
f.write('\n')
f.write('	__syncthreads();\n')
f.write('\n')
f.write('	for (int i = 0; i < 13; i++)\n')
f.write('	{\n')
f.write('		// calc fluxes, save to global\n')
f.write('		cuPosFlux(f, h, i, solid, sim, fluxf, fluxh);\n')
f.write('	}\n')
f.write('}\n')
f.write('\n')
f.write('__global__ void \n')
f.write('WALL_FLUXES(double2* f_flux, double2* h_flux, int* solid_d, simData* sim, double* TW, double2* uW)\n')
f.write('{\n')
f.write('	// calculate fluxes into solid nodes and set fluxes out of solid to cancel them out\n')
f.write('\n')
f.write('	// thread index\n')
f.write('	int tx = threadIdx.x;\n')
f.write('	int ty = threadIdx.y;\n')
f.write('\n')
f.write('	//global index\n')
f.write('	int ix = blockIdx.x*blockDim.x + tx;\n')
f.write('	int iy = blockIdx.y*blockDim.y + ty;\n')
f.write('\n')
f.write('	int Ny = (*sim).Ny;\n')
f.write('\n')
f.write('	int xm1, ym1, i, inv_i;\n')
f.write('	int mir_x, mir_y;\n')
f.write('\n')
f.write('	double dx = (*sim).dx;\n')
f.write('	double dy = (*sim).dy;\n')
f.write('\n')
f.write('	double flux_in, flux_out, alpha;\n')
f.write('\n')
f.write('	double feqW[13];\n')
f.write('	double heqW[13];\n')
f.write('\n')
f.write('	double ux, uy;\n')
f.write('\n')
f.write('	int inx,iny;\n')
f.write('\n')
f.write('	int sld = GSLD(ix,iy);\n')
f.write('\n')
f.write('	if ( sld >= 0)	//wall nodes\n')
f.write('	{\n')
f.write('		flux_in = 0;\n')
f.write('		flux_out = 0;\n')
f.write('\n')
f.write('		cuEq2D(1.0, uW[sld].x, uW[sld].y, TW[sld], (*sim).Tc, (*sim).R, (*sim).K, feqW, heqW);\n')
f.write('\n')
f.write('		// check surrounds for fluid node\n')
f.write('		for (int j = 0; j < 4; j++)\n')
f.write('		{\n')
f.write('			xm1 = cuIndex(ix,xx[j],0,sim,mir_y);\n')
f.write('			ym1 = cuIndex(iy,yy[j],1,sim,mir_x);\n')
f.write('\n')
f.write('			int sld2 = GSLD(xm1,ym1);\n')
f.write('\n')
f.write('			if (sld2 == -1) // if fluid\n')
f.write('			{\n')
f.write('				for (int k = 0; k < 4; k++)\n')
f.write('				{\n')
f.write('					i = ii[j][k];	// index of velocities into solid\n')
f.write('					inv_i = inv[j][k];	// inverted velocities, out of solid\n')
f.write('\n')
f.write('					// switches for turning off velocities that don't impinge on solid, or leave solid, through the cell pointed to by xx & yy\n')
f.write('					inx = abs(xx[j]);	\n')
f.write('					iny = abs(yy[j]);\n')
f.write('\n')
f.write('					flux_in += inx*GFLUXFx(xm1,ym1,i)/dx + iny*GFLUXFy(xm1,ym1,i)/dy;		// flux into solid\n')
f.write('\n')
f.write('					// absolute value of velocities\n')
f.write('					ux = abs((*sim).e[inv_i].x);	\n')
f.write('					uy = abs((*sim).e[inv_i].y);\n')
f.write('\n')
f.write('					flux_out += inx*feqW[inv_i]*ux/dx + iny*feqW[inv_i]*uy/dy;				// flux out of solid, back along inverse velocity\n')
f.write('				}\n')
f.write('			}\n')
f.write('		}\n')
f.write('\n')
f.write('		alpha = flux_in/flux_out;	// correction factor to equalise flux in to flux out\n')
f.write('\n')
f.write('		// load required fluxes into flux array\n')
f.write('		for (int i = 0; i < 13; i++)\n')
f.write('		{\n')
f.write('			ux = abs((*sim).e[i].x);	\n')
f.write('			uy = abs((*sim).e[i].y);\n')
f.write('\n')
f.write('			 GFLUXFx(ix,iy,i) = alpha*ux*feqW[i];\n')
f.write('			 GFLUXFy(ix,iy,i) = alpha*uy*feqW[i];\n')
f.write('\n')
f.write('			 GFLUXHx(ix,iy,i) = alpha*ux*heqW[i];\n')
f.write('			 GFLUXHy(ix,iy,i) = alpha*uy*heqW[i];\n')
f.write('		}\n')
f.write('	}\n')
f.write('}\n')
f.write('\n')
f.write('__global__ void\n')
f.write('	RK1_STEP1_KERNEL(double* f_d, double* f1_d, double* h_d, double* h1_d, int* solid_d, double* TW, double2* uW, double* rho_d, double2* u_d, double* T_d, simData* sim)\n')
f.write('{\n')
f.write('	//perform RK1 stepping\n')
f.write('\n')
f.write('	//global index\n')
f.write('	int ix = blockIdx.x*blockDim.x + threadIdx.x;\n')
f.write('	int iy = blockIdx.y*blockDim.y + threadIdx.y;\n')
f.write('\n')
f.write('	int Ny = (*sim).Ny;\n')
f.write('\n')
f.write('	double rho = GRHO(ix,iy);\n')
f.write('	double2 u = GU(ix,iy);\n')
f.write('	double T = GT(ix,iy);\n')
f.write('\n')
f.write('	double feq[13];\n')
f.write('	double heq[13];\n')
f.write('\n')
f.write('	int sld;\n')
f.write('\n')
f.write('	sld = GSLD(ix,iy);\n')
f.write('\n')
f.write('	// --- RK STEP ONE----\n')
f.write('	// calculate the first stage updated distribution functions \n')
f.write('\n')
f.write('	if (sld > -1 || sld == -2)	// check if node is solid or permanent, if it is, just propogate values\n')
f.write('	{\n')
f.write('		for (int i = 0; i < 13; i++)\n')
f.write('		{\n')
f.write('			GF1(ix,iy,i) = GF(ix,iy,i);\n')
f.write('			GH1(ix,iy,i) = GH(ix,iy,i);\n')
f.write('		}\n')
f.write('	}\n')
f.write('	else\n')
f.write('	{\n')
f.write('		// calculate relaxation times from macroscopic properties\n')
f.write('		double tauf = (*sim).mu/(rho*(*sim).R*T);\n')
f.write('		double tauh = tauf/(*sim).Pr;\n')
f.write('		double tauhf = (tauh*tauf)/(tauf - tauh);\n')
f.write('\n')
f.write('		double Tc = (*sim).Tc;\n')
f.write('		double R = (*sim).R;\n')
f.write('		double K = (*sim).K;\n')
f.write('\n')
f.write('		cuEq2D(rho, u.x, u.y, T, Tc, R, K, feq, heq);\n')
f.write('\n')
f.write('		double f1_, edotu;\n')
f.write('\n')
f.write('		for (int i = 0; i < 13; i++)\n')
f.write('		{\n')
f.write('			// temp variables\n')
f.write('			f1_ = (GF(ix,iy,i) + ((*sim).dt/tauf)*feq[i])/(1.0 + (*sim).dt/tauf);	//calc to temp variable first, for use later\n')
f.write('\n')
f.write('			GF1(ix,iy,i) = f1_;		// save to global\n')
f.write('\n')
f.write('			// temp variables\n')
f.write('			edotu = (*sim).e[i].x*u.x + (*sim).e[i].y*u.y;\n')
f.write('\n')
f.write('			GH1(ix,iy,i) = (GH(ix,iy,i) - (*sim).dt*edotu*((feq[i] - f1_)/tauhf) + ((*sim).dt/tauh)*heq[i])/(1.0 + (*sim).dt/tauh);\n')
f.write('		}\n')
f.write('	}\n')
f.write('}\n')
f.write('\n')
f.write('__global__ void\n')
f.write('	RK1_COMBINE_KERNEL(double* f_d, double* f1_d, double2* fluxf1_d, double* h_d, double* h1_d, double2* fluxh1_d, int* solid_d, double* TW, double2* uW, double* rho_d, double2* u_d, double* T_d, simData* sim)\n')
f.write('{\n')
f.write('	//combine step of RK1\n')
f.write('\n')
f.write('	//global index\n')
f.write('	int ix = blockIdx.x*blockDim.x + threadIdx.x;\n')
f.write('	int iy = blockIdx.y*blockDim.y + threadIdx.y;\n')
f.write('\n')
f.write('	int Ny = (*sim).Ny;\n')
f.write('\n')
f.write('	// macroscopic properties\n')
f.write('	double rho = GRHO(ix,iy);\n')
f.write('	double2 u = GU(ix,iy);\n')
f.write('	double T = GT(ix,iy);\n')
f.write('\n')
f.write('	// calculate relaxation times from macroscopic properties\n')
f.write('	double tauf = (*sim).mu/(rho*(*sim).R*T);\n')
f.write('	double tauh = tauf/(*sim).Pr;\n')
f.write('	double tauhf = (tauh*tauf)/(tauf - tauh);\n')
f.write('\n')
f.write('	double feq[13];\n')
f.write('	double heq[13];\n')
f.write('\n')
f.write('	double Tc = (*sim).Tc;\n')
f.write('	double R = (*sim).R;\n')
f.write('	double K = (*sim).K;\n')
f.write('\n')
f.write('	cuEq2D(rho, u.x, u.y, T, Tc, R, K, feq, heq);\n')
f.write('\n')
f.write('	double flux_f, flux_h, edotu;\n')
f.write('\n')
f.write('	int sld = GSLD(ix,iy);\n')
f.write('\n')
f.write('	for (int i = 0; i < 13; i++)\n')
f.write('	{\n')
f.write('\n')
f.write('		// --- RK COMBINATION ----\n')
f.write('		// calculate the updated distribution functions\n')
f.write('		if (sld == -1)\n')
f.write('		{\n')
f.write('			flux_f = cuCombineFLUX(fluxf1_d, i, sim);\n')
f.write('\n')
f.write('			GF(ix,iy,i) = GF(ix,iy,i) - flux_f + ((*sim).dt/tauf)*(feq[i] - GF1(ix,iy,i));\n')
f.write('\n')
f.write('			flux_h = cuCombineFLUX(fluxh1_d, i, sim);\n')
f.write('\n')
f.write('			edotu = (*sim).e[i].x*u.x + (*sim).e[i].y*u.y;\n')
f.write('\n')
f.write('			GH(ix,iy,i) = GH(ix,iy,i) - flux_h + ((*sim).dt/tauh)*(heq[i] - GH1(ix,iy,i)) - (((*sim).dt*edotu)/tauhf)*(feq[i] - GF1(ix,iy,i));\n')
f.write('		}\n')
f.write('	}\n')
f.write('}\n')
f.write('\n')
f.write('__global__ void\n')
f.write('	RK3_STEP1_KERNEL(double* f_d, double* f1_d, double* h_d, double* h1_d, int* solid_d, double* TW, double2* uW, double* rho_d, double2* u_d, double* T_d, simData* sim)\n')
f.write('{\n')
f.write('	//perform RK3 stepping\n')
f.write('\n')
f.write('	//global index\n')
f.write('	int ix = blockIdx.x*blockDim.x + threadIdx.x;\n')
f.write('	int iy = blockIdx.y*blockDim.y + threadIdx.y;\n')
f.write('\n')
f.write('	int Ny = (*sim).Ny;\n')
f.write('\n')
f.write('	double rho = GRHO(ix,iy);\n')
f.write('	double2 u = GU(ix,iy);\n')
f.write('	double T = GT(ix,iy);\n')
f.write('\n')
f.write('	double feq[13];\n')
f.write('	double heq[13];\n')
f.write('\n')
f.write('	int sld = GSLD(ix,iy);\n')
f.write('\n')
f.write('	// --- RK STEP ONE----\n')
f.write('	// calculate the first stage updated distribution functions \n')
f.write('\n')
f.write('	if (sld > -1 || sld == -2)\n')
f.write('	{\n')
f.write('		for (int i = 0; i < 13; i++)\n')
f.write('		{\n')
f.write('			GF1(ix,iy,i) = GF(ix,iy,i);\n')
f.write('			GH1(ix,iy,i) = GH(ix,iy,i);\n')
f.write('		}\n')
f.write('	}\n')
f.write('	else\n')
f.write('	{\n')
f.write('		// calculate relaxation times from macroscopic properties\n')
f.write('		double tauf = (*sim).mu/(rho*(*sim).R*T);\n')
f.write('		double tauh = tauf/(*sim).Pr;\n')
f.write('		double tauhf = (tauh*tauf)/(tauf - tauh);\n')
f.write('\n')
f.write('		double Tc = (*sim).Tc;\n')
f.write('		double R = (*sim).R;\n')
f.write('		double K = (*sim).K;\n')
f.write('\n')
f.write('		cuEq2D(rho, u.x, u.y, T, Tc, R, K, feq, heq);\n')
f.write('\n')
f.write('		double f1_, edotu;\n')
f.write('\n')
f.write('		for (int i = 0; i < 13; i++)\n')
f.write('		{\n')
f.write('			// temp variables\n')
f.write('			f1_ = (GF(ix,iy,i) + ((*sim).dt/(2*tauf))*feq[i])/(1.0 + (*sim).dt/(2*tauf));	//calc to temp variable first, for use later\n')
f.write('\n')
f.write('			GF1(ix,iy,i) = f1_;		// save to global\n')
f.write('\n')
f.write('			// temp variables\n')
f.write('			edotu = (*sim).e[i].x*u.x + (*sim).e[i].y*u.y;\n')
f.write('\n')
f.write('			GH1(ix,iy,i) = (GH(ix,iy,i) - ((*sim).dt/2.0)*edotu*((feq[i] - f1_)/tauhf) + ((*sim).dt/(2.0*tauh))*heq[i])/(1.0 + (*sim).dt/(2.0*tauh));\n')
f.write('		}\n')
f.write('	}\n')
f.write('}\n')
f.write('\n')
f.write('__global__ void\n')
f.write('	RK3_STEP2_KERNEL(double* f_d, double* f1_d, double* f2_d, double* h_d, double* h1_d, double* h2_d, int* solid_d, double* TW, double2* uW, double* rho_d, double2* u_d, double* T_d, simData* sim)\n')
f.write('{\n')
f.write('	//perform RK3 stepping\n')
f.write('\n')
f.write('	// NOTE: as all equilibrium df are calulated from the same data, feq1 = feq2 etc, this allows for simplification of equations\n')
f.write('\n')
f.write('	//global index\n')
f.write('	int ix = blockIdx.x*blockDim.x + threadIdx.x;\n')
f.write('	int iy = blockIdx.y*blockDim.y + threadIdx.y;\n')
f.write('\n')
f.write('	int Ny = (*sim).Ny;\n')
f.write('\n')
f.write('	double rho = GRHO(ix,iy);\n')
f.write('	double2 u = GU(ix,iy);\n')
f.write('	double T = GT(ix,iy);\n')
f.write('\n')
f.write('	double feq[13];\n')
f.write('	double heq[13];\n')
f.write('\n')
f.write('	int sld = GSLD(ix,iy);\n')
f.write('\n')
f.write('	// --- RK STEP TWO----\n')
f.write('	// calculate the first stage updated distribution functions \n')
f.write('\n')
f.write('	if (sld > -1 || sld == -2)\n')
f.write('	{\n')
f.write('		for (int i = 0; i < 13; i++)\n')
f.write('		{\n')
f.write('			GF2(ix,iy,i) = GF(ix,iy,i);\n')
f.write('			GH2(ix,iy,i) = GH(ix,iy,i);\n')
f.write('		}\n')
f.write('	}\n')
f.write('	else\n')
f.write('	{\n')
f.write('		// calculate relaxation times from macroscopic properties\n')
f.write('		double tauf = (*sim).mu/(rho*(*sim).R*T);\n')
f.write('		double tauh = tauf/(*sim).Pr;\n')
f.write('		double tauhf = (tauh*tauf)/(tauf - tauh);\n')
f.write('\n')
f.write('		double Tc = (*sim).Tc;\n')
f.write('		double R = (*sim).R;\n')
f.write('		double K = (*sim).K;\n')
f.write('\n')
f.write('		cuEq2D(rho, u.x, u.y, T, Tc, R, K, feq, heq);\n')
f.write('\n')
f.write('		double f1_, f2_, edotu;\n')
f.write('\n')
f.write('		for (int i = 0; i < 13; i++)\n')
f.write('		{\n')
f.write('			// temp variables\n')
f.write('			f1_ = GF1(ix,iy,i);\n')
f.write('			f2_ = (GF(ix,iy,i) + ((*sim).dt/(2*tauf))*f1_)/(1.0 + (*sim).dt/(2*tauf));	//calc to temp variable first, for use later\n')
f.write('\n')
f.write('			GF2(ix,iy,i) = f2_;		// save to global\n')
f.write('\n')
f.write('			// temp variables\n')
f.write('			edotu = (*sim).e[i].x*u.x + (*sim).e[i].y*u.y;\n')
f.write('\n')
f.write('			GH2(ix,iy,i) = (GH(ix,iy,i) - ((*sim).dt/2.0)*(edotu/tauhf)*(f1_ - f2_) + ((*sim).dt/2.0)*(GH1(ix,iy,i)/tauh))/(1.0 + (*sim).dt/(2.0*tauh));\n')
f.write('		}\n')
f.write('	}\n')
f.write('}\n')
f.write('\n')
f.write('__global__ void\n')
f.write('	RK3_MACRO_PROPERTIES(double* f_d, double* f2_d, double2* fluxf2, double* h_d, double* h2_d, double2* fluxh2, simData* sim, double* rho3_d, double2* u3_d, double* T3_d)\n')
f.write('{\n')
f.write('	//perform RK3 step 3 macroscopic properties calculation\n')
f.write('\n')
f.write('	// thread index\n')
f.write('	int tx = threadIdx.x;\n')
f.write('	int ty = threadIdx.y;\n')
f.write('\n')
f.write('	//global index\n')
f.write('	int ix = blockIdx.x*blockDim.x + tx;\n')
f.write('	int iy = blockIdx.y*blockDim.y + ty;\n')
f.write('\n')
f.write('	int Ny = (*sim).Ny;\n')
f.write('\n')
f.write('	//macro variables\n')
f.write('	__shared__ double rho_s[BLOCK_SIZE*BLOCK_SIZE];\n')
f.write('	__shared__ double2 u_s[BLOCK_SIZE*BLOCK_SIZE];\n')
f.write('	__shared__ double T_s[BLOCK_SIZE*BLOCK_SIZE];\n')
f.write('\n')
f.write('	// initialise to zero\n')
f.write('	SRHO(tx,ty) = 0;\n')
f.write('	SU(tx,ty).x = 0;\n')
f.write('	SU(tx,ty).y = 0;\n')
f.write('	ST(tx,ty) = 0;\n')
f.write('\n')
f.write('	double f, h, flux_f, flux_h;\n')
f.write('\n')
f.write('	for (int i = 0; i < 13; i++)\n')
f.write('	{\n')
f.write('		// load f, and h, from global memory\n')
f.write('		f = GF(ix,iy,i);\n')
f.write('		h = GH(ix,iy,i);\n')
f.write('\n')
f.write('		//calculate fluxes\n')
f.write('		flux_f = cuCombineFLUX(fluxf2, i, sim);\n')
f.write('		flux_h = cuCombineFLUX(fluxh2, i, sim);		\n')
f.write('\n')
f.write('		SRHO(tx,ty) += f - flux_f;\n')
f.write('		SU(tx,ty).x += (f - flux_f)*(*sim).e[i].x;\n')
f.write('		SU(tx,ty).y += (f - flux_f)*(*sim).e[i].y;\n')
f.write('		ST(tx,ty) += h - flux_h;		\n')
f.write('	}\n')
f.write('	\n')
f.write('	SU(tx,ty).x = SU(tx,ty).x / SRHO(tx,ty);\n')
f.write('	SU(tx,ty).y = SU(tx,ty).y / SRHO(tx,ty);\n')
f.write('\n')
f.write('	double usq = sqrt(SU(tx,ty).x*SU(tx,ty).x + SU(tx,ty).y*SU(tx,ty).y);\n')
f.write('\n')
f.write('	usq = usq*usq;\n')
f.write('	\n')
f.write('	ST(tx,ty) = 2.0*(ST(tx,ty)/SRHO(tx,ty) - usq/2.0)/((*sim).b*(*sim).R);\n')
f.write('\n')
f.write('	// save to global memory\n')
f.write('	GRHO3(ix,iy) = SRHO(tx,ty);\n')
f.write('	GU3(ix,iy) = SU(tx,ty);\n')
f.write('	GT3(ix,iy) = ST(tx,ty);\n')
f.write('}\n')
f.write('\n')
f.write('__global__ void\n')
f.write('RK3_STEP3_KERNEL(double* f_d, double* f2_d, double*f3_d, double2* fluxf2, double* h_d, double* h2_d, double* h3_d, double2* fluxh2, int* solid_d, double* TW, double2* uW, \n')
f.write('double* rho_d, double2* u_d, double* T_d, double* rho3_d, double2* u3_d, double* T3_d, simData* sim)\n')
f.write('{\n')
f.write('	//perform RK3 stepping\n')
f.write('\n')
f.write('	//global index\n')
f.write('	int ix = blockIdx.x*blockDim.x + threadIdx.x;\n')
f.write('	int iy = blockIdx.y*blockDim.y + threadIdx.y;\n')
f.write('\n')
f.write('	int Ny = (*sim).Ny;\n')
f.write('\n')
f.write('	double rho3 = GRHO3(ix,iy);\n')
f.write('	double2 u3 = GU3(ix,iy);\n')
f.write('	double T3 = GT3(ix,iy);\n')
f.write('	\n')
f.write('	double feq3[13];\n')
f.write('	double heq3[13];\n')
f.write('\n')
f.write('	double Tc = (*sim).Tc;\n')
f.write('	double R = (*sim).R;\n')
f.write('	double K = (*sim).K;\n')
f.write('\n')
f.write('	int sld = GSLD(ix,iy);\n')
f.write('\n')
f.write('	// --- RK STEP THREE ----\n')
f.write('	// calculate the third stage updated distribution functions \n')
f.write('\n')
f.write('	// macroscopic properties\n')
f.write('	double rho2 = GRHO(ix,iy);\n')
f.write('	double2 u2 = GU(ix,iy);\n')
f.write('	double T2 = GT(ix,iy);\n')
f.write('\n')
f.write('	// calculate relaxation times from macroscopic properties\n')
f.write('	double tauf2 = (*sim).mu/(rho2*(*sim).R*T2);\n')
f.write('	double tauh2 = tauf2/(*sim).Pr;\n')
f.write('	double tauhf2 = (tauh2*tauf2)/(tauf2 - tauh2);\n')
f.write('\n')
f.write('	double tauf3 = (*sim).mu/(rho3*(*sim).R*T3);\n')
f.write('	double tauh3 = tauf3/(*sim).Pr;\n')
f.write('	double tauhf3 = (tauh3*tauf3)/(tauf3 - tauh3);\n')
f.write('\n')
f.write('	double feq2[13];\n')
f.write('	double heq2[13];\n')
f.write('\n')
f.write('	cuEq2D(rho2, u2.x, u2.y, T2, Tc, R, K, feq2, heq2);\n')
f.write('	cuEq2D(rho3, u3.x, u3.y, T3, Tc, R, K, feq3, heq3);\n')
f.write('\n')
f.write('	double flux_f2, flux_h2, edotu2, edotu3, f2_, f3_;\n')
f.write('\n')
f.write('	for (int i = 0; i < 13; i++)\n')
f.write('	{\n')
f.write('		// calculate the updated distribution functions\n')
f.write('		if (sld == -1)\n')
f.write('		{\n')
f.write('			flux_f2 = cuCombineFLUX(fluxf2, i, sim);\n')
f.write('\n')
f.write('			f2_ = GF2(ix,iy,i);\n')
f.write('\n')
f.write('			f3_ = (GF(ix,iy,i) - flux_f2 + ((*sim).dt/(2*tauf2))*(feq2[i] - f2_) + ((*sim).dt/(2*tauf3))*feq3[i])/(1 + (*sim).dt/(2*tauf3));\n')
f.write('\n')
f.write('			GF3(ix,iy,i) = f3_;\n')
f.write('\n')
f.write('			flux_h2 = cuCombineFLUX(fluxh2, i, sim);\n')
f.write('\n')
f.write('			edotu2 = (*sim).e[i].x*u2.x + (*sim).e[i].y*u2.y;\n')
f.write('			edotu3 = (*sim).e[i].x*u3.x + (*sim).e[i].y*u3.y;\n')
f.write('\n')
f.write('			GH3(ix,iy,i) = (GH(ix,iy,i) - flux_h2 - ((*sim).dt/2.0)*(edotu2*((feq2[i] - f2_)/tauhf2) + edotu3*((feq3[i] - f3_)/tauhf3)) + \n')
f.write('				((*sim).dt/2.0)*((heq2[i] - GH2(ix,iy,i))/tauh2) + ((*sim).dt/2.0)*(heq3[i]/tauh3))/(1 + (*sim).dt/(2*tauh3));\n')
f.write('		}\n')
f.write('		else\n')
f.write('		{\n')
f.write('			GF3(ix,iy,i) = GF(ix,iy,i);\n')
f.write('			GH3(ix,iy,i) = GH(ix,iy,i);\n')
f.write('		}\n')
f.write('	}\n')
f.write('}\n')
f.write('\n')
f.write('__global__ void\n')
f.write('RK3_COMBINE_KERNEL(double* f_d, double* f2_d, double* f3_d, double2* fluxf2, double2* fluxf3, double* h_d, double* h2_d, double* h3_d, \n')
f.write('double2* fluxh2, double2* fluxh3, double* rho_d, double2* u_d, double* T_d, double* rho3_d, double2* u3_d, double* T3_d, simData* sim, int* solid_d)\n')
f.write('{\n')
f.write('	//perform RK3 combination step\n')
f.write('\n')
f.write('	//global index\n')
f.write('	int ix = blockIdx.x*blockDim.x + threadIdx.x;\n')
f.write('	int iy = blockIdx.y*blockDim.y + threadIdx.y;\n')
f.write('\n')
f.write('	int Ny = (*sim).Ny;\n')
f.write('\n')
f.write('	// macroscopic properties\n')
f.write('	double rho2 = GRHO(ix,iy);\n')
f.write('	double2 u2 = GU(ix,iy);\n')
f.write('	double T2 = GT(ix,iy);\n')
f.write('\n')
f.write('	double rho3 = GRHO3(ix,iy);\n')
f.write('	double2 u3 = GU3(ix,iy);\n')
f.write('	double T3 = GT3(ix,iy);\n')
f.write('\n')
f.write('	// calculate relaxation times from macroscopic properties\n')
f.write('	double tauf2 = (*sim).mu/(rho2*(*sim).R*T2);\n')
f.write('	double tauh2 = tauf2/(*sim).Pr;\n')
f.write('	double tauhf2 = (tauh2*tauf2)/(tauf2 - tauh2);\n')
f.write('\n')
f.write('	double tauf3 = (*sim).mu/(rho3*(*sim).R*T3);\n')
f.write('	double tauh3 = tauf3/(*sim).Pr;\n')
f.write('	double tauhf3 = (tauh3*tauf3)/(tauf3 - tauh3);\n')
f.write('\n')
f.write('	double feq2[13];\n')
f.write('	double heq2[13];\n')
f.write('\n')
f.write('	double feq3[13];\n')
f.write('	double heq3[13];\n')
f.write('\n')
f.write('	double Tc = (*sim).Tc;\n')
f.write('	double R = (*sim).R;\n')
f.write('	double K = (*sim).K;\n')
f.write('\n')
f.write('	cuEq2D(rho2, u2.x, u2.y, T2, Tc, R, K, feq2, heq2);\n')
f.write('	cuEq2D(rho3, u3.x, u3.y, T3, Tc, R, K, feq3, heq3);\n')
f.write('\n')
f.write('	double flux_f2, flux_h2, flux_f3, flux_h3, edotu2, edotu3;\n')
f.write('	double f2_, f3_, h2_, h3_;\n')
f.write('\n')
f.write('	int sld = GSLD(ix,iy);\n')
f.write('\n')
f.write('	for (int i = 0; i < 13; i++)\n')
f.write('	{\n')
f.write('		// --- RK COMBINATION ----\n')
f.write('		// calculate the updated distribution functions\n')
f.write('		if (sld == -1)\n')
f.write('		{\n')
f.write('\n')
f.write('			f2_ = GF2(ix,iy,i);\n')
f.write('			f3_ = GF3(ix,iy,i);\n')
f.write('\n')
f.write('			flux_f2 = cuCombineFLUX(fluxf2, i, sim);\n')
f.write('			flux_f3 = cuCombineFLUX(fluxf3, i, sim);\n')
f.write('\n')
f.write('			GF(ix,iy,i) = GF(ix,iy,i) - (1.0/2.0)*(flux_f2 + flux_f3) + ((*sim).dt/2.0)*((feq2[i] - f2_)/tauf2 + (feq3[i] - f3_)/tauf3);\n')
f.write('\n')
f.write('			h2_ = GH2(ix,iy,i);\n')
f.write('			h3_ = GH3(ix,iy,i);\n')
f.write('\n')
f.write('			flux_h2 = cuCombineFLUX(fluxh2, i, sim);\n')
f.write('			flux_h3 = cuCombineFLUX(fluxh3, i, sim);\n')
f.write('\n')
f.write('			edotu2 = (*sim).e[i].x*u2.x + (*sim).e[i].y*u2.y;\n')
f.write('			edotu3 = (*sim).e[i].x*u3.x + (*sim).e[i].y*u3.y;\n')
f.write('\n')
f.write('			GH(ix,iy,i) = GH(ix,iy,i) - 0.5*(flux_h2 + flux_h3) + ((*sim).dt/2.0)*((heq2[i] - h2_)/tauh2 + (heq3[i] - h3_)/tauh3) \n')
f.write('				- ((*sim).dt/2.0)*((edotu2/tauhf2)*(feq2[i] - f2_) + (edotu3/tauhf3)*(feq3[i] - f3_));\n')
f.write('		}\n')
f.write('	}\n')
f.write('	__syncthreads();\n')
f.write('}\n')
