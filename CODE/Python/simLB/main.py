# simLB
# 08/04/2011
"""
simLB is a Python port of my code for the 2D lattice Boltzmann method that
was originally coded in C++/CUDA
uses pyOpenCL for 'brains' of code
"""

#########################
## PACKAGES
#########################

import numpy as np
from enthought.mayavi import mlab
from enthought.tvtk.api import tvtk
from LBM import ClassLBM
import time
import pyopencl as cl


import matplotlib
matplotlib.use('TkAgg') # do this before importing pylab

import matplotlib.pyplot as plt

#########################
## FUNCTIONS
#########################

class PlotRect:
    def getData(self,data_D, data_H, name):
        """
        plot passed in data as a surface
        """
        
        #plotting
        fig = mlab.figure(size = (512,512))
        mlab.view(90,0)
        
        cl.enqueue_read_buffer(lbm.queue, data_D, data_H).wait()
        
        rgrid = tvtk.RectilinearGrid()
        rgrid.cell_data.scalars = data_H.ravel()
        rgrid.cell_data.scalars.name = 'scalars'
        
        
        rgrid.dimensions = np.array((lbm.Ny+1, lbm.Nx+1, 1))
        rgrid.x_coordinates = lbm.Y
        rgrid.y_coordinates = lbm.X
        rgrid.z_coordinates = np.array([0.0])
        
        src = mlab.pipeline.add_dataset(rgrid)
        s = mlab.pipeline.cell_to_point_data(src)
        s = mlab.pipeline.surface(s)
        sb = mlab.scalarbar(s, title = name)
        
        #plot lines
        if 1:
            mlab.pipeline.surface(mlab.pipeline.extract_edges(src),
                                  color=(0, 0, 0),line_width = 0.1, opacity = 0.05)
    
        self.rgrid = rgrid
        self.src = src
        self.data_D = data_D
        self.data_H = data_H

    def updateData(self):
        """
        update figure initialised by plotData()
        """
        
        cl.enqueue_read_buffer(lbm.queue, self.data_D, self.data_H).wait()
        
        self.rgrid.cell_data.scalars = self.data_H.ravel()
        self.rgrid.cell_data.scalars.name = 'scalars'
        self.rgrid.modified()
        self.src.update()

class PlotSurf:
    
    def getData(self, data_D, data_H, name):
        """
        plot passed in data as a surface
        """
        
        #plotting
        fig = mlab.figure(size = (512,512))
        
        cl.enqueue_read_buffer(lbm.queue, data_D, data_H).wait()
        
        # retrieve mid cell points from cell node data
        Nx = lbm.X.size - 1
        Ny = lbm.Y.size - 1
        x = np.zeros((Nx))
        y = np.zeros((Ny))
        
        for i in range(1,lbm.X.size):
            x[i-1] = (lbm.X[i] - lbm.X[i-1])/2.0 + lbm.X[i-1]
        
        for i in range(1,lbm.Y.size):
            y[i-1] = (lbm.Y[i] - lbm.Y[i-1])/2.0 + lbm.Y[i-1]
        
        s = mlab.surf(x,y,data_H, warp_scale = 'auto', colormap = "jet")
        mlab.axes(s)
        sb = mlab.scalarbar(s, title = name)
        
        self.s = s
        self.data_D = data_D
        self.data_H = data_H

    def updateData(self):
        """ update the plot generated by plot1D"""
        
        cl.enqueue_read_buffer(lbm.queue, self.data_D, self.data_H).wait()
        
        self.s.mlab_source.scalars = self.data_H

class PlotLine:
    def getData(self, n, axis, data_D, data_H, name):
        """get data from device"""
        cl.enqueue_read_buffer(lbm.queue, data_D, data_H).wait()

        # retrieve mid cell points from cell node data
        if axis == 'x':
            N = lbm.X.size - 1
            X = lbm.X
            y = data_H[:,n]
        elif axis == 'y':
            N = lbm.Y.size - 1
            X = lbm.Y
            y = data_H[n,:]
        
        x = np.zeros((N))
        
        for i in range(1,X.size):
            x[i-1] = (X[i] - X[i-1])/2.0 + X[i-1]
            
        self.x = x
        self.y = y
        self.n = n
        self.axis = axis
        self.data_D = data_D
        self.data_H = data_H
        self.name = name
        
        self.plotLine()
        
        return
        
    def plotLine(self):
        """plot a 2D graph of data"""
        self.fig = plt.figure()
        ax = self.fig.add_subplot(111)
        self.line, = ax.plot(self.x, self.y)
        self.fig.canvas.draw()
        plt.title(self.name)
        #turn on interactive
        plt.ion()
        plt.show()
        
        return
    
    def updateData(self):
        """ update the plot to reflect changes in data"""
        cl.enqueue_read_buffer(lbm.queue, self.data_D, self.data_H).wait()
        
        
        if self.axis == 'x':
            self.y = self.data_H[:,self.n]
        elif self.axis == 'y':
            self.y = self.data_H[self.n,:]
        
        self.line.set_ydata(self.y)
        self.fig.canvas.draw()
        
#########################
## MAIN FUNCTIONALITY
#########################

# generate and initialise the primary simulation class
#  string indicates the initialisation script to use

#lbm = ClassLBM("makeQuarterCircle")
#lbm = ClassLBM("makeFullCircle")
#lbm = ClassLBM("makeLaxLiu3")
#lbm = ClassLBM("makeBoundaryLayer")
lbm = ClassLBM("makePlaneShock")

#initialise plots
fig1 = PlotRect()
fig1.getData(lbm.rho_D, lbm.rho_H, 'density')

fig2 = PlotLine()
fig2.getData(0,'x',lbm.rho_D, lbm.rho_H,'density')

fig3 = PlotLine()
fig3.getData(0,'x',lbm.T_D, lbm.T_H,'temperature')

fig4 = PlotLine()
fig4.getData(0,'x',lbm.ux_D, lbm.ux_H,'velocity')


## MAIN LOOP
t0 = time.clock()
for i in range(lbm.steps):
    
    lbm.runSimStep()
    
    if i%lbm.nPrintOut == 0:
        fig1.updateData()
        fig2.updateData()
        fig3.updateData()
        fig4.updateData()

    print('step {}/{}'.format(i+1,lbm.steps))
t = time.clock() - t0
print('total time elapsed = {}'.format(t))

plt.ioff()
plt.show()



